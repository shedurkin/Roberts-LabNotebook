---
title: "Timeseries molecular: A.pul, multiomic features to predict expression. Machine learning -- Part 2"
author: "Kathleen Durkin"
date: "2025-04-23"
categories: ["E5-coral"]
format:
  html:
    toc: true
execute: 
  eval: FALSE
engine: knitr
bibliography: ../../../references.bib
---

[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22.2-Apul-multiomic-machine-learning.Rmd)

[Rendered Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22.2-Apul-multiomic-machine-learning.md)

Applying ML model using multiomic predictors -- miRNA + lncRNA + methylation as predictors of gene expression. This time, instead of reducing the dimensionality of all sets using PCs, I'm using vsd-transformed miRNA/lncRNA/CpG counts as predictors, and vsd-transformed gene counts as responses.

Excluding the dimensionality-reduction makes the model training much more computationally intensive, so I only ran it for the smaller gene sets (Host biomass, ATP production GO terms, Energy usage/storage GO terms).

Inputs:

-   RNA counts matrix (raw): `../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv`

-   Gene sets of interest: `../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/`

-   sRNA/miRNA counts matrix (raw): `../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt`

-   lncRNA counts matrix (raw): `../output/08-Apul-lncNRA/counts.txt`

-   WGBS data (processed): Performed in `/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/`, data in [large-file storage](https://gannet.fish.washington.edu/seashell/bu-github/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/).

-   sample metadata: `../../M-multi-species/data/rna_metadata.csv`

# 1 Set up

# 2 Load libraries

``` r
library(tidyverse)
library(ggplot2)
library(DESeq2)
library(igraph)
library(psych)
library(tidygraph)
library(ggraph)
library(WGCNA)
library(edgeR)
library(reshape2)
library(ggcorrplot)
library(corrplot)
library(rvest)
library(purrr)
library(pheatmap)
library(glmnet)
library(caret)
library(factoextra)
library(vegan)
library(ggfortify)
library(genefilter)
library(scales)
```

The model includes random processes, so set a seed for reproducability. Note: for final results, should we consider bootstrapping to ensure reported results are representative?

``` r
set.seed(703)
```

# 3 Load and format data

## 3.1 RNA-seq data (mRNA, miRNA, lncRNA)

``` r
### mRNA ###
# raw gene counts data (will filter and variance stabilize)
Apul_genes <- read_csv("../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv")
```

```         
## Rows: 44371 Columns: 41
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr  (1): gene_id
## dbl (40): 1A1, 1A10, 1A12, 1A2, 1A8, 1A9, 1B1, 1B10, 1B2, 1B5, 1B9, 1C10, 1C...
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

``` r
Apul_genes <- as.data.frame(Apul_genes)

# format gene IDs as rownames (instead of a column)
rownames(Apul_genes) <- Apul_genes$gene_id
Apul_genes <- Apul_genes%>%select(!gene_id)


### miRNA ###
# raw miRNA counts (will filter and variance stabilize)
Apul_miRNA <- read.table(file = "../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt", header = TRUE, sep = "\t", check.names = FALSE)


### lncRNA ###
# raw lncRNA counts (will filter and variance stabilize)
Apul_lncRNA_full <- read.table("../output/08-Apul-lncRNA/counts.txt", header = TRUE, sep = "\t", skip = 1)

# Remove info on genomic location, set lncRNA IDs as rownames
rownames(Apul_lncRNA_full) <- Apul_lncRNA_full$Geneid
Apul_lncRNA <- Apul_lncRNA_full %>% select(-Geneid, -Chr, -Start, -End, -Strand, -Length)



### load and format metadata ###
metadata <- read_csv("../../M-multi-species/data/rna_metadata.csv")%>%select(AzentaSampleName, ColonyID, Timepoint) %>%
  filter(grepl("ACR", ColonyID))
```

```         
## New names:
## Rows: 117 Columns: 19
## ── Column specification
## ──────────────────────────────────────────────────────── Delimiter: "," chr
## (13): SampleName, WellNumber, AzentaSampleName, ColonyID, Timepoint, Sam... dbl
## (5): SampleNumber, Plate, TotalAmount-ng, Volume-uL, Conc-ng.uL lgl (1):
## MethodUsedForSpectrophotometry
## ℹ Use `spec()` to retrieve the full column specification for this data. ℹ
## Specify the column types or set `show_col_types = FALSE` to quiet this message.
## • `` -> `...19`
```

``` r
metadata$Sample <- paste0(metadata$ColonyID, "-", metadata$Timepoint)
rownames(metadata) <- metadata$Sample
```

```         
## Warning: Setting row names on a tibble is deprecated.
```

``` r
colonies <- unique(metadata$ColonyID)

# Rename gene column names to include full sample info
colnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]

# Rename miRNA column names to match formatting
colnames(Apul_miRNA) <- sub("_.*", "", colnames(Apul_miRNA))
colnames(Apul_miRNA) <- metadata$Sample[match(colnames(Apul_miRNA), metadata$AzentaSampleName)]

# rename lncRNA colin names to include full sample info
colnames(Apul_lncRNA) <- sub("...data.", "", colnames(Apul_lncRNA))
colnames(Apul_lncRNA) <- sub(".sorted.bam", "", colnames(Apul_lncRNA))
colnames(Apul_lncRNA) <- metadata$Sample[match(colnames(Apul_lncRNA), metadata$AzentaSampleName)]
```

## 3.2 WGBS data

``` r
#pull processed files from Gannet 
# Note: Unfortunately we can't use the `cache` feature to make this process more time efficient, as it doesn't support long vectors

# Define the base URL
base_url <- "https://gannet.fish.washington.edu/seashell/bu-github/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/"

# Read the HTML page
page <- read_html(base_url)

# Extract links to files
file_links <- page %>%
  html_nodes("a") %>%
  html_attr("href")

# Filter for files ending in "processed.txt"
processed_files <- file_links[grepl("processed\\.txt$", file_links)]

# Create full URLs
file_urls <- paste0(base_url, processed_files)

# Function to read a file from URL
read_processed_file <- function(url) {
  read_table(url, col_types = cols(.default = "c"))  # Read as character to avoid parsing issues
}

# Import all processed files into a list
processed_data <- lapply(file_urls, read_processed_file)

# Name the list elements by file name
names(processed_data) <- processed_files

# Print structure of imported data
str(processed_data)

# add a header row that has "CpG" for the first column and "sample" for the second column, which will be populated by the file name 

processed_data <- Map(function(df, filename) {
  colnames(df) <- c("CpG", filename)  # Rename columns
  return(df)
}, processed_data, names(processed_data))  # Use stored file names

#merge files together by "CpG"
merged_data <- purrr::reduce(processed_data, full_join, by = "CpG")

# Print structure of final merged data
str(merged_data)
```

Replace any NA with 0.

``` r
# Convert all columns (except "CpG") to numeric and replace NAs with 0
merged_data <- merged_data %>%
  mutate(across(-CpG, as.numeric)) %>%  # Convert all except CpG to numeric
  mutate(across(-CpG, ~ replace_na(.x, 0)))  # Replace NA with 0 in numeric columns
```

## 3.3 Filter data sets

Only keep CpGs that have a non-zero value in all samples.

``` r
filtered_wgbs <- merged_data %>% filter(if_all(-CpG, ~ .x > 0))

# Ensure it's formatted as a data frame
filtered_wgbs <- as.data.frame(filtered_wgbs)
# Only keep the sample information in the column name. 
colnames(filtered_wgbs) <- gsub("^(.*?)_.*$", "\\1", colnames(filtered_wgbs))
# Set CpG IDs to rownames
rownames(filtered_wgbs) <- filtered_wgbs$CpG
filtered_wgbs <- filtered_wgbs %>% select(-CpG)

nrow(merged_data)
nrow(filtered_wgbs)
```

We had 12,093,025 CpGs before filtering and have only 507 after filtering. This makes sense because most CpGs were not methylated in all samples.

Save filtered set to make code reruns/knitting quicker

``` r
write.csv(filtered_wgbs, "../output/22.2-Apul-multiomic-machine-learning/filtered-WGBS-CpG-counts.csv")
```

If knitting/rerunning code, we can load in this filtered data here, instead of loading raw counts and reprocessing.

``` r
filtered_wgbs <- read.csv("../output/22.2-Apul-multiomic-machine-learning/filtered-WGBS-CpG-counts.csv", row.names = 1, check.names = FALSE)
```

Only keep genes, miRNA, and lncRNA that are present in at least one sample

``` r
# genes
Apul_genes_red <- Apul_genes[rowSums(Apul_genes) != 0, ]
# miRNA
Apul_miRNA_red <- Apul_miRNA[rowSums(Apul_miRNA) != 0, ]
# lncRNA
Apul_lncRNA_red <- Apul_lncRNA[rowSums(Apul_lncRNA) != 0, ]

cat("Retained ", nrow(Apul_genes_red), " of ", nrow(Apul_genes), "genes; ",
       nrow(Apul_miRNA_red), " of ", nrow(Apul_miRNA), " miRNA; and ", 
       nrow(Apul_lncRNA_red), " of ", nrow(Apul_lncRNA), " lncRNA")
```

```         
## Retained  35869  of  44371 genes;  51  of  51  miRNA; and  20559  of  24181  lncRNA
```

*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Setting 3/40 = 0.08. This would retain genes that are only expressed in a single season in a couple of the colonies. Additionally, setting the minimum count so that the minimum number of samples must have a gene count above a certain threshold.

genes:

``` r
filt <- filterfun(pOverA(0.08, 5))

#create filter for the counts data
gfilt <- genefilter(Apul_genes_red, filt)

#identify genes to keep by count filter
gkeep <- Apul_genes_red[gfilt,]

#identify gene lists
gn.keep <- rownames(gkeep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
Apul_genes_filt <- as.data.frame(Apul_genes_red[which(rownames(Apul_genes_red) %in% gn.keep),])

#How many rows do we have before and after filtering?
cat("Pre-filtering:", nrow(Apul_genes_red), "; Post-filtering:", nrow(Apul_genes_filt))
```

```         
## Pre-filtering: 35869 ; Post-filtering: 25730
```

miRNA:

``` r
mifilt <- filterfun(pOverA(0.08, 5))

#create filter for the counts data
mifilt <- genefilter(Apul_miRNA_red, mifilt)

#identify miRNA to keep by count filter
mikeep <- Apul_miRNA_red[mifilt,]

#identify miRNA to keep by count filter
mikeep <- Apul_miRNA_red[mifilt,]

#identify miRNA lists
mi.keep <- rownames(mikeep)

#miRNA count data filtered in PoverA, P percent of the samples have counts over A
Apul_miRNA_filt <- as.data.frame(Apul_miRNA_red[which(rownames(Apul_miRNA_red) %in% mi.keep),])

#How many rows do we have before and after filtering?
cat("Pre-filtering:", nrow(Apul_miRNA_red), "; Post-filtering:", nrow(Apul_miRNA_filt))
```

```         
## Pre-filtering: 51 ; Post-filtering: 47
```

Of the 51 miRNA, 47 were retained. Which were removed?

``` r
setdiff(rownames(Apul_miRNA_red), rownames(Apul_miRNA_filt))
```

```         
## [1] "Cluster_5685"  "Cluster_11565" "Cluster_13647" "Cluster_14633"
```

lncRNA:

``` r
lncfilt <- filterfun(pOverA(0.08, 5))

#create filter for the counts data
lncfilt <- genefilter(Apul_lncRNA_red, lncfilt)

#identify lncRNA to keep by count filter
lnckeep <- Apul_lncRNA_red[lncfilt,]

#identify lncRNA to keep by count filter
lnckeep <- Apul_lncRNA_red[lncfilt,]

#identify lncRNA lists
lnc.keep <- rownames(lnckeep)

#lncRNA count data filtered in PoverA, P percent of the samples have counts over A
Apul_lncRNA_filt <- as.data.frame(Apul_lncRNA_red[which(rownames(Apul_lncRNA_red) %in% lnc.keep),])

#How many rows do we have before and after filtering?
cat("Pre-filtering:", nrow(Apul_lncRNA_red), "; Post-filtering:", nrow(Apul_lncRNA_filt))
```

```         
## Pre-filtering: 20559 ; Post-filtering: 16006
```

## 3.4 Transform data

Set the order of genes, miRNA, lncRNA, wgbs, and metadata to all be the same.

``` r
# Ensure rownames of metadata are used as the desired column order
desired_order <- rownames(metadata)

# Reorder data frame columns
Apul_genes_filt <- Apul_genes_filt[, desired_order]
Apul_miRNA_filt <- Apul_miRNA_filt[, desired_order]
Apul_lncRNA_filt <- Apul_lncRNA_filt[, desired_order]
filtered_wgbs <- filtered_wgbs[, desired_order]

# Check they all match
identical(rownames(metadata), colnames(Apul_genes_filt))
```

```         
## [1] TRUE
```

``` r
identical(rownames(metadata), colnames(Apul_miRNA_filt))
```

```         
## [1] TRUE
```

``` r
identical(rownames(metadata), colnames(Apul_lncRNA_filt))
```

```         
## [1] TRUE
```

``` r
identical(rownames(metadata), colnames(filtered_wgbs))
```

```         
## [1] TRUE
```

Use a variance stabilized transformation for all four data sets. Variance stabilization essentially tries to make variance independent of the mean

(Is this the most appropriate design to use?)

genes:

``` r
dds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt, 
                              colData = metadata, 
                              design = ~Timepoint+ColonyID)
```

```         
## converting counts to integer mode

## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
## design formula are characters, converting to factors

##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]
```

``` r
# Variance Stabilizing Transformation
vsd_genes <- assay(vst(dds_genes, blind = TRUE))
```

miRNA:

``` r
dds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt, 
                              colData = metadata, 
                              design = ~Timepoint+ColonyID)
```

```         
## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
## design formula are characters, converting to factors

##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]
```

``` r
# Variance Stabilizing Transformation
vsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=TRUE) # Must use varianceStabilizingTransformation() instead of vst() due to few input genes
```

```         
##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]
```

``` r
vsd_miRNA <- assay(vsd_miRNA)
```

lncRNA:

``` r
dds_lncRNA <- DESeqDataSetFromMatrix(countData = Apul_lncRNA_filt, 
                              colData = metadata, 
                              design = ~Timepoint+ColonyID)
```

```         
## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
## design formula are characters, converting to factors

##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]
```

``` r
# Variance Stabilizing Transformation
vsd_lncRNA <- assay(vst(dds_lncRNA, blind = TRUE))
```

Must round wgbs data to whole integers for normalization - need to return to this to decide if this is appropriate.

``` r
#round to integers 
filtered_wgbs<-filtered_wgbs %>% mutate(across(where(is.numeric), round))

dds_wgbs <- DESeqDataSetFromMatrix(countData = filtered_wgbs, 
                              colData = metadata, 
                              design = ~ Timepoint+ColonyID)
```

```         
## converting counts to integer mode

## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
## design formula are characters, converting to factors

##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]
```

``` r
# Variance Stabilizing Transformation
vsd_wgbs <- assay(varianceStabilizingTransformation(dds_wgbs, blind = TRUE))
```

```         
##   Note: levels of factors in the design contain characters other than
##   letters, numbers, '_' and '.'. It is recommended (but not required) to use
##   only letters, numbers, and delimiters '_' or '.', as these are safe characters
##   for column names in R. [This is a message, not a warning or an error]

## -- note: fitType='parametric', but the dispersion trend was not well captured by the
##    function: y = a/x + b, and a local regression fit was automatically substituted.
##    specify fitType='local' or 'mean' to avoid this message next time.
```

## 3.5 Islolate gene sets

Read in gene set tables

``` r
# genes from WGCNA modules significantly correlated with host biomass
Host_AFDW <- read.table("../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Host_AFDW.mg.cm2_gene_counts.tab", sep="\t", header=TRUE)
# genes from WGCNA modules significantly correlated with symbiont photosynthesis
Am <- read.table("../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Am_gene_counts.tab", sep="\t", header=TRUE)
# GO terms related to energy production/usage
ATP_production_GO <- read.table("../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/ATP_production_GO_terms_gene_counts.tab", sep="\t", header=TRUE)
energy_GO <- read.table("../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/energy_usage_storage_GO_terms_gene_counts.tab", sep="\t", header=TRUE)
```

Isolate filtered counts by gene set

``` r
vsd_Host_AFDW <- vsd_genes[rownames(vsd_genes) %in% Host_AFDW$gene_id,]
vsd_Am <- vsd_genes[rownames(vsd_genes) %in% Am$gene_id,]
vsd_ATP_production_GO <- vsd_genes[rownames(vsd_genes) %in% ATP_production_GO$gene_id,]
vsd_energy_GO <- vsd_genes[rownames(vsd_genes) %in% energy_GO$gene_id,]
```

# 5 Merge predictor features

## 5.2 Merge raw datsets

I also want to try using individiual miRNA/lncRNA/CpGs as predictors, instead of the reduced PCs. Let's also create a merged dataset that contains the variance stabilized counts for all miRNA, lncRNA, and CpGs.

``` r
# Triple check that all three data frames have sample names in the same order
identical(colnames(vsd_lncRNA), colnames(vsd_miRNA))
```

```         
## [1] TRUE
```

``` r
identical(colnames(vsd_lncRNA), colnames(vsd_wgbs))
```

```         
## [1] TRUE
```

``` r
# Bind (stack dataframes vertically, so that they match by column/sample)
full_pred_counts <- rbind(vsd_lncRNA, vsd_miRNA, vsd_wgbs)

# Transform so that samples are on rows and features are in columns
full_pred_counts <- t(full_pred_counts)

dim(full_pred_counts)
```

```         
## [1]    40 16560
```

Ok, now we can run the model!

The below code uses both predictors (miRNA+lncRNA+CpGs) and responses (genes) that have been *not* been reduced using PCs.

``` r
# Transform the counts matrices so that samples are on the rows and gene IDs on the columns
vsd_genes_t <- t(vsd_genes)
vsd_Host_AFDW_t <- t(vsd_Host_AFDW)
vsd_Am_t <- t(vsd_Am)
vsd_ATP_production_GO_t <- t(vsd_ATP_production_GO)
vsd_energy_GO_t <- t(vsd_energy_GO)

# Ensure both are formatted as data frames
full_pred_counts <- as.data.frame(full_pred_counts)
vsd_genes_t <- as.data.frame(vsd_genes_t)
vsd_Host_AFDW_t <- as.data.frame(vsd_Host_AFDW_t)
vsd_Am_t <- as.data.frame(vsd_Am_t)
vsd_ATP_production_GO_t <- as.data.frame(vsd_ATP_production_GO_t)
vsd_energy_GO_t <- as.data.frame(vsd_energy_GO_t)

# Ensure sample matching between gene and epigenetic dfs
common_samples <- intersect(rownames(vsd_genes_t), rownames(full_pred_counts))

full_pred_counts <- full_pred_counts[common_samples, ]
vsd_genes_t <- vsd_genes_t[common_samples, ]
vsd_Host_AFDW_t <- vsd_Host_AFDW_t[common_samples,]
vsd_Am_t <- vsd_Am_t[common_samples,]
vsd_ATP_production_GO_t <- vsd_ATP_production_GO_t[common_samples,]
vsd_energy_GO_t <- vsd_energy_GO_t[common_samples,]
```

# 14 Host biomass (Host_AFDW)

## 14.1 The model

Train elastic models to predict gene expression from miRNA/lncRNA/methylation.

``` r
train_models <- function(response_features, predictor_features) {
  models <- list()
  
  for (feature in colnames(response_features)) {
    y <- response_features[[feature]]  # Gene expression
    X <- as.matrix(predictor_features)  # miRNA/lncRNA/methylation as predictors
    
    # Train elastic net model (alpha = 0.5 for mix of LASSO & Ridge)
    model <- cv.glmnet(X, y, alpha = 0.5)
    
    models[[feature]] <- model
  }
  
  return(models)
}

# Train models predicting gene expression from miRNA/lncRNA/methylation
models_Host_AFDW <- train_models(vsd_Host_AFDW_t, full_pred_counts)
```

Extract feature importance.

``` r
get_feature_importance <- function(models) {
  importance_list <- lapply(models, function(model) {
    coefs <- as.matrix(coef(model, s = "lambda.min"))[-1, , drop = FALSE]  # Convert to regular matrix & remove intercept
    
    # Convert to data frame
    coefs_df <- data.frame(Feature = rownames(coefs), Importance = as.numeric(coefs))
    
    return(coefs_df)
  })
  
  # Combine feature importance across all predicted genes
  importance_df <- bind_rows(importance_list) %>%
    group_by(Feature) %>%
    summarize(MeanImportance = mean(abs(Importance)), .groups = "drop") %>%
    arrange(desc(MeanImportance))
  
  return(importance_df)
}

feature_importance_Host_AFDW <- get_feature_importance(models_Host_AFDW)
head(feature_importance_Host_AFDW, 20)  # Top predictive features
```

```         
## # A tibble: 20 × 2
##    Feature    MeanImportance
##    <chr>               <dbl>
##  1 PC20_miRNA         0.0906
##  2 PC18_miRNA         0.0771
##  3 PC17_miRNA         0.0762
##  4 PC19_miRNA         0.0760
##  5 PC16_miRNA         0.0753
##  6 PC8_miRNA          0.0689
##  7 PC3_miRNA          0.0674
##  8 PC13_miRNA         0.0672
##  9 PC11_miRNA         0.0669
## 10 PC7_miRNA          0.0663
## 11 PC9_miRNA          0.0581
## 12 PC27_WGBS          0.0527
## 13 PC26_WGBS          0.0516
## 14 PC2_miRNA          0.0505
## 15 PC14_miRNA         0.0471
## 16 PC5_miRNA          0.0463
## 17 PC12_miRNA         0.0440
## 18 PC21_WGBS          0.0430
## 19 PC13_WGBS          0.0430
## 20 PC11_WGBS          0.0354
```

Evaluate performance.

``` r
evaluate_model_performance <- function(models, response_features, predictor_features) {
  results <- data.frame(Feature = colnames(response_features), R2 = NA)

  for (feature in colnames(response_features)) {
    y <- response_features[[feature]]
    X <- as.matrix(predictor_features)

    model <- models[[feature]]
    preds <- predict(model, X, s = "lambda.min")

    R2 <- cor(y, preds)^2  # R-squared metric
    results[results$Feature == feature, "R2"] <- R2
  }

  return(results)
}

performance_results_Host_AFDW <- evaluate_model_performance(models_Host_AFDW, vsd_Host_AFDW_t, full_pred_counts)
summary(performance_results_Host_AFDW$R2)
```

```         
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##  0.0000  0.9554  0.9919  0.9498  0.9996  0.9998      14
```

## 14.2 Results

Plot results.

``` r
# Select top predictive features
top_features_Host_AFDW <- feature_importance_Host_AFDW %>% top_n(50, MeanImportance)

# Plot
ggplot(top_features_Host_AFDW, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for readability
  theme_minimal() +
  labs(title = "miRNA/lncRNA/methylation as predictive features",
       x = "Features",
       y = "Mean Importance")
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-90-1.png)<!-- -->

``` r
ggplot(performance_results_Host_AFDW, aes(x = as.factor(Feature), y = R2)) +
  geom_point(color = "darkred", size = 1) +
  geom_hline(yintercept = mean(performance_results_Host_AFDW$R2, na.rm = TRUE), linetype = "dashed", color = "blue") +
  theme_minimal() +
  labs(title = "Model Performance Across Genes",
       x = "Gene",
       y = "R² (Variance Explained)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels
```

```         
## Warning: Removed 14 rows containing missing values or values outside the scale range
## (`geom_point()`).
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-91-1.png)<!-- -->

We can also look at which feature(s) contributed most to predicting genes of interest

``` r
# Will keep this unevaluated to reduce size of knitted document
all_features_Host_AFDW <- performance_results_Host_AFDW %>% filter(R2 > 0.95) %>% pull(Feature)

get_feature_importance_for_feature <- function(model) {
  coefs <- as.matrix(coef(model, s = "lambda.min"))[-1, , drop = FALSE]  # Remove intercept
  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))
  
  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance
}

for (feature in all_features_Host_AFDW) {
  # Extract feature importance for the most predictable gene
  best_feature_model <- models_Host_AFDW[[feature]]
  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)
  
  # Plot top most important miRNA/lncRNA/methylation for predicting this gene
  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top miRNA/lncRNA/methylation Predictors for", feature),
         x = "Feature",
         y = "Importance Score")
  
  print(plot)
}
```

``` r
# Compute correlation between actual and predicted genes
predicted_matrix <- sapply(models_Host_AFDW, function(m) predict(m, as.matrix(full_pred_counts), s = "lambda.min"))

# Ensure matrices are the same size
predicted_matrix <- predicted_matrix[, colnames(vsd_Host_AFDW_t), drop = FALSE]  # Align columns

# remove 0 variance columns
predicted_matrix <- predicted_matrix[, apply(predicted_matrix, 2, function(col) sd(col, na.rm = TRUE) > 0)]

# Compute correlation matrix, handling missing values
cor_matrix <- cor(predicted_matrix, as.matrix(vsd_Host_AFDW_t), use = "complete.obs")

# Replace NA or Inf values with zero
cor_matrix[is.na(cor_matrix) | is.infinite(cor_matrix)] <- 0  

# Plot heatmap
pheatmap(cor_matrix, color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Correlation Between Actual and Predicted Genes",
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         fontsize = 10)
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-93-1.png)<!-- -->

# 15 Symbiont photsynthesis (Am)

## 15.1 The model

Train elastic models to predict gene expression from miRNA/lncRNA/methylation

``` r
# Train models predicting gene expression from miRNA/lncRNA/methylation
models_Am <- train_models(vsd_Am_t, full_pred_counts)
```

Extract feature importance.

``` r
feature_importance_Am <- get_feature_importance(models_Am)
head(feature_importance_Am, 20)  # Top predictive features
```

Evaluate performance.

``` r
performance_results_Am <- evaluate_model_performance(models_Am, vsd_Am_t, full_pred_counts)
summary(performance_results_Am$R2)
```

## 15.2 Results

Plot results.

``` r
# Select top predictive features
top_features_Am <- feature_importance_Am %>% top_n(50, MeanImportance)

# Plot
ggplot(top_features_Am, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for readability
  theme_minimal() +
  labs(title = "miRNA/lncRNA/methylation as Predictive Features",
       x = "Feature",
       y = "Mean Importance")
```

``` r
ggplot(performance_results_Am, aes(x = as.factor(Feature), y = R2)) +
  geom_point(color = "darkred", size = 3) +
  geom_hline(yintercept = mean(performance_results_Am$R2, na.rm = TRUE), linetype = "dashed", color = "blue") +
  theme_minimal() +
  labs(title = "Model Performance Across Gene Expression PCs",
       x = "Gene Expression PC",
       y = "R² (Variance Explained)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels
```

View predicted vs actual gene expression values to evaluate model.

``` r
# Choose a gene expression PC to visualize (e.g., the most predictable one)
best_feature_Am <- performance_results_Am$Feature[which.max(performance_results_Am$R2)]

# Extract actual and predicted values for that PC
actual_values_Am <- vsd_Am_t[[best_feature_Am]]
predicted_values_Am <- predict(models_Am[[best_feature_Am]], as.matrix(full_pred_counts), s = "lambda.min")

# Create data frame
prediction_df_Am <- data.frame(
  Actual = actual_values_Am,
  Predicted = predicted_values_Am
)

# Scatter plot with regression line
ggplot(prediction_df_Am, aes(x = Actual, y = lambda.min)) +
  geom_point(color = "blue", alpha = 0.7) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  theme_minimal() +
  labs(title = paste("Predicted vs. Actual for", best_feature_Am),
       x = "Actual Gene Expression PC",
       y = "Predicted Gene Expression PC") +
  annotate("text", x = min(actual_values_Am), y = max(predicted_values_Am), 
           label = paste("R² =", round(max(performance_results_Am$R2, na.rm=TRUE), 3)), 
           hjust = 0, color = "black", size = 5)
## `geom_smooth()` using formula = 'y ~ x'
```

View top 20 genes associated with the PC with the highest R\^2

``` r
print(top_genes_Am%>%filter(Am_Feature==best_feature_Am))
```

Plot performance for all PCs

``` r
# Select all PCs with R^2 values above 0.75
all_features_Am <- performance_results_Am %>% filter(R2 > 0.75) %>% pull(Feature)

for (feature in all_features_Am) {
  
  # Extract actual and predicted values for that PC
  actual_values <- vsd_Am_t[[feature]]
  predicted_values <- predict(models_Am[[feature]], as.matrix(full_pred_counts), s = "lambda.min")
  
  # Create data frame
  prediction_df <- data.frame(
    Actual = actual_values,
    Predicted = predicted_values
  )
  
  # Scatter plot with regression line
  plot <- ggplot(prediction_df, aes(x = Actual, y = lambda.min)) +
    geom_point(color = "blue", alpha = 0.7) +
    geom_smooth(method = "lm", color = "red", se = FALSE) +
    theme_minimal() +
    labs(title = paste("Predicted vs. Actual for", feature),
         x = "Actual Gene Expression PC",
         y = "Predicted Gene Expression PC") +
    annotate("text", x = min(actual_values), y = max(predicted_values), 
             label = paste("R² =", round(max(performance_results_Am[performance_results_Am$Feature==feature,2], na.rm=TRUE), 3)), 
             hjust = 0, color = "black", size = 5)
  
  print(plot)
}
```

We can also look at which miRNA(s) contributed most to predicting gene PCs of interest

``` r
get_feature_importance_for_feature <- function(model) {
  coefs <- as.matrix(coef(model, s = "lambda.min"))[-1, , drop = FALSE]  # Remove intercept
  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))
  
  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance
}

for (feature in all_features_Am) {
  # Extract feature importance for the most predictable PC
  best_feature_model <- models_Am[[feature]]
  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)
  
  # Plot top most important miRNA/lncRNA/methylation for predicting this PC
  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top miRNA/lncRNA/methylation Predictors for", feature),
         x = "Feature",
         y = "Importance Score")
  
  print(plot)
}
```

# 16 ATP production (GO terms)

## 16.1 The model

Train elastic models to predict gene expression PCs from miRNA/lncRNA/methylation

``` r
# Train models predicting gene expression PCs from miRNA/lncRNA/methylation
models_ATP_prod_GO <- train_models(vsd_ATP_production_GO_t, full_pred_counts)
```

Extract feature importance.

``` r
feature_importance_ATP_prod_GO <- get_feature_importance(models_ATP_prod_GO)
head(feature_importance_ATP_prod_GO, 20)  # Top predictive miRNA
```

```         
## # A tibble: 20 × 2
##    Feature                MeanImportance
##    <chr>                           <dbl>
##  1 lncRNA_16172                  0.0151 
##  2 lncRNA_19034                  0.0137 
##  3 lncRNA_3645                   0.0125 
##  4 lncRNA_20796                  0.0110 
##  5 lncRNA_4454                   0.00999
##  6 lncRNA_8058                   0.00920
##  7 lncRNA_18277                  0.00918
##  8 CpG_ptg000024l_4334252        0.00893
##  9 lncRNA_9242                   0.00818
## 10 lncRNA_263                    0.00782
## 11 lncRNA_3622                   0.00781
## 12 lncRNA_9252                   0.00773
## 13 CpG_ptg000031l_5273398        0.00716
## 14 lncRNA_19773                  0.00687
## 15 CpG_ptg000022l_2983280        0.00683
## 16 lncRNA_11719                  0.00667
## 17 CpG_ptg000024l_213653         0.00665
## 18 lncRNA_23085                  0.00664
## 19 lncRNA_18158                  0.00655
## 20 lncRNA_7887                   0.00652
```

Evaluate performance.

``` r
performance_results_ATP_prod_GO <- evaluate_model_performance(models_ATP_prod_GO, vsd_ATP_production_GO_t, full_pred_counts)
summary(performance_results_ATP_prod_GO$R2)
```

```         
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.0000  0.9644  0.9957  0.9366  0.9996  0.9997
```

## 16.2 Results

Plot results.

``` r
# Select top predictive features
top_features_ATP_prod_GO <- feature_importance_ATP_prod_GO %>% top_n(50, MeanImportance)

# Plot
ggplot(top_features_ATP_prod_GO, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for readability
  theme_minimal() +
  labs(title = "miRNA/lncRNA/methylation as Predictive Features",
       x = "Feature",
       y = "Mean Importance")
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-106-1.png)<!-- -->

``` r
ggplot(performance_results_ATP_prod_GO, aes(x = as.factor(Feature), y = R2)) +
  geom_point(color = "darkred", size = 3) +
  geom_hline(yintercept = mean(performance_results_ATP_prod_GO$R2, na.rm = TRUE), linetype = "dashed", color = "blue") +
  theme_minimal() +
  labs(title = "Model Performance Across Gene Expression PCs",
       x = "Gene Expression PC",
       y = "R² (Variance Explained)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-107-1.png)<!-- -->

View predicted vs actual gene expression values to evaluate model.

``` r
# Choose a gene expression PC to visualize (e.g., the most predictable one)
best_feature_ATP_prod_GO <- performance_results_ATP_prod_GO$Feature[which.max(performance_results_ATP_prod_GO$R2)]

# Extract actual and predicted values for that PC
actual_values_ATP_prod_GO <- vsd_ATP_production_GO_t[[best_feature_ATP_prod_GO]]
predicted_values_ATP_prod_GO <- predict(models_ATP_prod_GO[[best_feature_ATP_prod_GO]], as.matrix(full_pred_counts), s = "lambda.min")

# Create data frame
prediction_df_ATP_prod_GO <- data.frame(
  Actual = actual_values_ATP_prod_GO,
  Predicted = predicted_values_ATP_prod_GO
)

# Scatter plot with regression line
ggplot(prediction_df_ATP_prod_GO, aes(x = Actual, y = lambda.min)) +
  geom_point(color = "blue", alpha = 0.7) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  theme_minimal() +
  labs(title = paste("Predicted vs. Actual for", best_feature_ATP_prod_GO),
       x = "Actual Gene Expression PC",
       y = "Predicted Gene Expression PC") +
  annotate("text", x = min(actual_values_ATP_prod_GO), y = max(predicted_values_ATP_prod_GO), 
           label = paste("R² =", round(max(performance_results_ATP_prod_GO$R2, na.rm=TRUE), 3)), 
           hjust = 0, color = "black", size = 5)
```

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-108-1.png)<!-- -->

``` r
## `geom_smooth()` using formula = 'y ~ x'
```

Plot performance for all PCs

``` r
# Select all PCs with R^2 values above line in plot
all_features_ATP_prod_GO <- performance_results_ATP_prod_GO %>% filter(R2 > 0.75) %>% pull(Feature)

for (feature in all_features_ATP_prod_GO) {
  
  # Extract actual and predicted values for that PC
  actual_values <- vsd_ATP_production_GO_t[[feature]]
  predicted_values <- predict(models_ATP_prod_GO[[feature]], as.matrix(full_pred_counts), s = "lambda.min")
  
  # Create data frame
  prediction_df <- data.frame(
    Actual = actual_values,
    Predicted = predicted_values
  )
  
  # Scatter plot with regression line
  plot <- ggplot(prediction_df, aes(x = Actual, y = lambda.min)) +
    geom_point(color = "blue", alpha = 0.7) +
    geom_smooth(method = "lm", color = "red", se = FALSE) +
    theme_minimal() +
    labs(title = paste("Predicted vs. Actual for", feature),
         x = "Actual Gene Expression PC",
         y = "Predicted Gene Expression PC") +
    annotate("text", x = min(actual_values), y = max(predicted_values), 
             label = paste("R² =", round(max(performance_results_ATP_prod_GO[performance_results_ATP_prod_GO$Feature==feature,2], na.rm=TRUE), 3)), 
             hjust = 0, color = "black", size = 5)
  
  print(plot)
}
```

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-1.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-2.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-3.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-4.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-5.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-6.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-7.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-8.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-9.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-10.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-11.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-12.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-13.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-14.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-15.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-16.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-17.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-18.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-19.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-20.png)<!-- -->

```         
## `geom_smooth()` using formula = 'y ~ x'
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-21.png)<!-- -->

We can also look at which miRNA(s) contributed most to predicting gene PCs of interest

``` r
get_feature_importance_for_feature <- function(model) {
  coefs <- as.matrix(coef(model, s = "lambda.min"))[-1, , drop = FALSE]  # Remove intercept
  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))
  
  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance
}

for (feature in all_features_ATP_prod_GO) {
  # Extract feature importance for the most predictable PC
  best_feature_model <- models_ATP_prod_GO[[feature]]
  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)
  
  # Plot top most important miRNA/lncRNA/methylation for predicting this PC
  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top miRNA/lncRNA/methylation Predictors for", feature),
         x = "Feature",
         y = "Importance Score")
  
  print(plot)
}
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-1.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-2.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-3.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-4.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-5.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-6.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-7.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-8.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-9.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-10.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-11.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-12.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-13.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-14.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-15.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-16.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-17.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-18.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-19.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-20.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-21.png)<!-- -->

``` r
# Compute correlation between actual and predicted gene expression PCs
predicted_matrix <- sapply(models_ATP_prod_GO, function(m) predict(m, as.matrix(full_pred_counts), s = "lambda.min"))

# Ensure matrices are the same size
predicted_matrix <- predicted_matrix[, colnames(vsd_ATP_production_GO_t), drop = FALSE]  # Align columns

# remove 0 variance columns
predicted_matrix <- predicted_matrix[, apply(predicted_matrix, 2, function(col) sd(col, na.rm = TRUE) > 0)]

# Compute correlation matrix, handling missing values
cor_matrix <- cor(predicted_matrix, as.matrix(vsd_ATP_production_GO_t), use = "complete.obs")

# Replace NA or Inf values with zero
cor_matrix[is.na(cor_matrix) | is.infinite(cor_matrix)] <- 0  

# Plot heatmap
pheatmap(cor_matrix, color = colorRampPalette(c("blue", "white", "red"))(100),
         main = "Correlation Between Actual and Predicted Gene Expression PCs",
         cluster_rows = FALSE,
         cluster_cols = FALSE,
         fontsize = 10)
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-111-1.png)<!-- -->

# 17 Energy Usage/Storage (GO terms)

## 17.1 The model

Train elastic models to predict gene expression PCs from miRNA/lncRNA/methylation

``` r
# Train models predicting gene expression PCs from miRNA/lncRNA/methylation
models_energy_GO <- train_models(vsd_energy_GO_t, full_pred_counts)
```

Extract feature importance.

``` r
feature_importance_energy_GO <- get_feature_importance(models_energy_GO)
head(feature_importance_energy_GO, 20)  # Top predictive miRNA
```

```         
## # A tibble: 20 × 2
##    Feature                 MeanImportance
##    <chr>                            <dbl>
##  1 lncRNA_19034                   0.00555
##  2 lncRNA_4454                    0.00373
##  3 lncRNA_2998                    0.00302
##  4 lncRNA_12064                   0.00248
##  5 CpG_ptg000025l_18378678        0.00244
##  6 lncRNA_12212                   0.00237
##  7 lncRNA_8086                    0.00221
##  8 lncRNA_20796                   0.00216
##  9 lncRNA_13960                   0.00215
## 10 lncRNA_263                     0.00214
## 11 lncRNA_21989                   0.00210
## 12 lncRNA_15222                   0.00210
## 13 lncRNA_7887                    0.00208
## 14 CpG_ptg000024l_4334565         0.00206
## 15 lncRNA_16584                   0.00205
## 16 lncRNA_6545                    0.00203
## 17 lncRNA_1395                    0.00199
## 18 lncRNA_22939                   0.00199
## 19 lncRNA_16417                   0.00198
## 20 CpG_ptg000021l_8434453         0.00194
```

Evaluate performance.

``` r
performance_results_energy_GO <- evaluate_model_performance(models_energy_GO, vsd_energy_GO_t, full_pred_counts)
summary(performance_results_energy_GO$R2)
```

```         
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##  0.3597  0.9565  0.9950  0.9574  0.9996  0.9998       3
```

## 17.2 Results

Plot results.

``` r
# Select top predictive features
top_features_energy_GO <- feature_importance_energy_GO %>% top_n(50, MeanImportance)

# Plot
ggplot(top_features_energy_GO, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +  # Flip for readability
  theme_minimal() +
  labs(title = "miRNA/lncRNA/methylation as Predictive Features",
       x = "Feature",
       y = "Mean Importance")
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-115-1.png)<!-- -->

``` r
ggplot(performance_results_energy_GO, aes(x = as.factor(Feature), y = R2)) +
  geom_point(color = "darkred", size = 1.5) +
  geom_hline(yintercept = mean(performance_results_energy_GO$R2, na.rm = TRUE), linetype = "dashed", color = "blue") +
  theme_minimal() +
  labs(title = "Model Performance Across Gene Expression PCs",
       x = "Gene Expression PC",
       y = "R² (Variance Explained)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels
```

```         
## Warning: Removed 3 rows containing missing values or values outside the scale range
## (`geom_point()`).
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-116-1.png)<!-- -->

We can also look at which miRNA(s) contributed most to predicting gene PCs of interest

``` r
# Will keep this unevaluated to reduce size of knitted document
get_feature_importance_for_feature <- function(model) {
  coefs <- as.matrix(coef(model, s = "lambda.min"))[-1, , drop = FALSE]  # Remove intercept
  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))
  
  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance
}

all_features_energy_GO <- performance_results_energy_GO %>% filter(R2 > 0.75) %>% pull(Feature)

for (feature in all_features_energy_GO) {
  # Extract feature importance for the most predictable PC
  best_feature_model <- models_energy_GO[[feature]]
  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)
  
  # Plot top most important miRNA/lncRNA/methylation for predicting this PC
  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +
    geom_bar(stat = "identity", fill = "steelblue") +
    coord_flip() +
    theme_minimal() +
    labs(title = paste("Top miRNA/lncRNA/methylation Predictors for", feature),
         x = "Feature",
         y = "Importance Score")
  
  print(plot)
}
```

# 18 Compare

Visualize the relative importance of miRNA/lncRNA/methylation in predicting expression for these different gene sets:

``` r
# Perform min-max normalization on the mean importance of miRNA/lncRNA/methylation for each group
# This will place all along a 0-1 range for comparison purposes
normalize <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

# Normalize
top_features_Host_AFDW$MeanImportance_norm <- normalize(top_features_Host_AFDW$MeanImportance)
#top_features_Am$MeanImportance_norm <- normalize(top_features_Am$MeanImportance)
top_features_ATP_prod_GO$MeanImportance_norm <- normalize(top_features_ATP_prod_GO$MeanImportance)
top_features_energy_GO$MeanImportance_norm <- normalize(top_features_energy_GO$MeanImportance)

# Add group labels
top_features_Host_AFDW <- top_features_Host_AFDW %>% mutate(group = "Host_AFDW")
#top_features_Am <- top_features_Am %>% mutate(group = "Am")
top_features_ATP_prod_GO <- top_features_ATP_prod_GO %>% mutate(group = "ATP_prod_GO")
top_features_energy_GO <- top_features_energy_GO %>% mutate(group = "energy_GO")

# Set rows in same order
#top_features_Am <- top_features_Am[rownames(top_features_Host_AFDW),]
top_features_ATP_prod_GO <- top_features_ATP_prod_GO[rownames(top_features_Host_AFDW),]
top_features_energy_GO <- top_features_energy_GO[rownames(top_features_Host_AFDW),]

# Combine
all_gene_sets <- bind_rows(top_features_Host_AFDW, 
                           #top_features_Am, 
                           top_features_ATP_prod_GO, top_features_energy_GO)
# Remove raw mean importance
all_gene_sets <- all_gene_sets %>% select(!MeanImportance)

# Wide format: rows = miRNAs, columns = groups
heatmap_df <- all_gene_sets %>%
  pivot_wider(names_from = group, values_from = MeanImportance_norm)

heatmap_df <- as.data.frame(heatmap_df)

# Melt into long format for ggplot
heatmap_long <- melt(heatmap_df, id.vars = "Feature")

ggplot(heatmap_long, aes(x = variable, y = Feature, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "red") +
  theme_minimal() +
  labs(x = "Group", y = "Feature", fill = "Importance") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-118-1.png)<!-- -->

Cluster by miRNA/lncRNA/methylation importance

``` r
# Make Feature column the rownames and convert to matrix
rownames(heatmap_df) <- heatmap_df$Feature
heatmap_matrix <- as.matrix(heatmap_df[, -1])  # Removes the 'Feature' column

# Replace NAs with 0
heatmap_matrix[is.na(heatmap_matrix)] <- 0

pheatmap(
  heatmap_matrix, 
  cluster_rows = TRUE,  # Clustering miRNAs (rows) by similarity in importance
  cluster_cols = TRUE,  # Clustering groups (columns)
  scale = "none",  # No scaling (since data is already normalized)
  show_rownames = TRUE,  # Show miRNA/lncRNA/methylation names
  show_colnames = TRUE,  # Show group names
  color = colorRampPalette(c("white", "red"))(100),  # Red gradient for importance
  main = "miRNAs Importance Across Groups"  # Title of the heatmap
)
```

![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-119-1.png)<!-- -->
