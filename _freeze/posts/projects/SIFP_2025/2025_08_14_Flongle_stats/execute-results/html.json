{
  "hash": "dfaa5f4503af1b772120372e456877d5",
  "result": {
    "markdown": "---\ntitle: \"Estimate Flow Cell OUtputs\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-08_14\"\ncategories: [\"SIFP-2025\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: TRUE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\nUsing the outputs from my Flongle run of Group1, Library 1, I want to use the rate of pore decay and cumulative sequencing output to extrapolate how much output to expect from other flow cells.\n\n## Pore activity\n\nLook at the output csv of pore activity stats:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: package 'dplyr' was built under R version 4.2.3\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\npore_activity <- read.csv(\"./data/2025_08_12_Flongle_Group1_Library1/pore_activity_AYW935_f9a34344_e98d3daf.csv\")\npore_activity$Percent <- pore_activity$State.Time..samples./378000\n# unique(pore_activity$Channel.State)\npore_activity$Channel.State <- factor(pore_activity$Channel.State,\n                                         levels = c(\"unclassified\", \"unclassified_following_reset\", \"unknown_negative\", \"unknown_positive\", \"disabled\", \"saturated\", \"multiple\", \"zero\", \"no_pore\", \"unblocking\", \"unavailable\", \"pore\", \"adapter\", \"strand\"),\n                                      ordered = TRUE)\n\nggplot(pore_activity, aes(x = Experiment.Time..minutes., y = Percent, color = Channel.State)) +\n  geom_col()\n```\n\n::: {.cell-output-display}\n![](2025_08_14_Flongle_stats_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nCompare to Summary Plot:\n\n![](data/2025_08_12_Flongle_Group1_Library1/PoreActivity.png)\n\nAfter comparing the pore_activity.csv labels to those included in the pore activity summary plots, I'm pretty sure that the following labels are equivalent (pore_activity.csv label = plot label)\n\nadapter = adapter\\\ndisabled = channel disabled\\\nlocked = ?\\\nmultiple = multiple\\\nno_pore = no pore\\\npending_manual_reset = ?\\\npending_mux_change = ?\\\n**pore = pore available**\\\nsaturated = saturated\\\n**strand = sequencing**\\\nunavailable = unavailable\\\nunblocking = active feedback\\\nunclassified = unclassified\\\nunclassified_following_reset = ?\\\nunknown_negative = out of range - low\\\nunknown_positive = out of range - high\\\nzero = zero\n\n## Fit pore decay and output functions\n\nI want to extract a function for the percent of pores that are sequencing over time. I expect a roughly exponential drop of pore activity over time\n\n\n::: {.cell}\n\n```{.r .cell-code}\npore_sequencing <- pore_activity %>% \n  filter(Channel.State == \"strand\")\n\n# Fit exponential decay\nstart_vals <- list(a = max(pore_sequencing$Percent), b = 0.01, c = min(pore_sequencing$Percent))\nmodel <- nls(Percent ~ a * exp(-b * Experiment.Time..minutes.) + c,\n             data = pore_sequencing, start = start_vals)\n\n#summary(model)\n\n# Predict and plot\npore_sequencing$fit <- predict(model)\n\n\npore_sequencing %>%\n  ggplot(., aes(x = Experiment.Time..minutes., y = Percent)) + \n  geom_point() +\n  geom_line(aes(y = fit), color = \"red\", size = 1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nâ„¹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](2025_08_14_Flongle_stats_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncat(\"\\n\")\n```\n\n```{.r .cell-code}\ncat(\"\\n\")\n```\n\n```{.r .cell-code}\ncat(\"Best fit line for percent of pores that are actively sequencing as a function of time:\", \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBest fit line for percent of pores that are actively sequencing as a function of time: \n```\n:::\n\n```{.r .cell-code}\ncat(\"Percent = \", round(coef(model)[\"a\"], 3), \"* exp(-\", round(coef(model)[\"b\"], 3), \"* [minutes]) +\", round(coef(model)[\"c\"], 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPercent =  15.377 * exp(- 0.004 * [minutes]) + 1.503\n```\n:::\n:::\n\n\nThe dramatic, periodic drops in sequencing represents the pore scans, which were set to occur every 1.5hr.\n\nNow I want to find the sequencing output (in b or Mb) as a function of time\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthroughput <- read.csv(\"./data/2025_08_12_Flongle_Group1_Library1/throughput_AYW935_f9a34344_e98d3daf(in).csv\")\n\n# Fit exponential decay\nstart_vals <- list(a = max(throughput$Basecalled.Bases), b = 0.01, c = min(throughput$Basecalled.Bases))\nmodel2 <- nls(Basecalled.Bases ~ a * exp(-b * Experiment.Time..minutes.) + c,\n             data = throughput, start = start_vals)\n\n#summary(model2)\n\n# Predict and plot\nthroughput$fit <- predict(model2)\n\nthroughput %>%\n  ggplot(., aes(x = Experiment.Time..minutes., y = Basecalled.Bases)) + \n  geom_point() +\n  geom_line(aes(y = fit), color = \"red\", size = 1)\n```\n\n::: {.cell-output-display}\n![](2025_08_14_Flongle_stats_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\ncat(\"\\n\")\n```\n\n```{.r .cell-code}\ncat(\"\\n\")\n```\n\n```{.r .cell-code}\ncat(\"Best fit line for percent of pores that are actively sequencing as a function of time:\", \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBest fit line for percent of pores that are actively sequencing as a function of time: \n```\n:::\n\n```{.r .cell-code}\ncat(\"Bases = \", round(coef(model2)[\"a\"], 3), \"* exp(-\", round(coef(model2)[\"b\"], 3), \"* [minutes]) +\", round(coef(model2)[\"c\"], 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBases =  -120848296 * exp(- 0.002 * [minutes]) + 127537896\n```\n:::\n:::\n\n\n## Estimate output of flow cell\n\nNow I want to use these to estimate MinION output based on a different starting number of pores.\n\n::: callout-note\nNote that these estimates will be based on the assumption that MinION pores degrade at the same rate as these Flongle pores which, based on rather negative experiences posted to the Nanopor community, may not be the case. People have reported that their v10 Flongles degrade much more quickly than both older Flongle chemistry and Minion flow cells.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Given\n## Starting number of pores\nPref <- 44\n## Cumulative output function\nCref <- function(t) { -120848296 * exp(-0.002 * t) + 127537896 }  # bases\n\n# Prediction for a new run\npredict_yield <- function(P0, T_minutes) {\n  Cref(T_minutes) * (P0 / Pref)               # bases\n}\n\n# Convenience: return Gb\npredict_yield_Gb <- function(P0, T_minutes) {\n  predict_yield(P0, T_minutes) / 1e9\n}\n\n# Run a MinION flow cell with 1200 pores for 3 days (no washes)\npredict_yield_Gb(1200, 4320)  # Gb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.477723\n```\n:::\n\n```{.r .cell-code}\n# Run a MinION flow cell with 1200 pores for 3 days, with wash/reloads that recover/maintain half of pores each time\npredict_yield_Gb(1200, 1440) + predict_yield_Gb(600, 1440) + predict_yield_Gb(300, 1440)   # Gb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.763264\n```\n:::\n:::\n\n\nIn the future, if I find that MinION pores decay at a different rate, I can use the below code to incorporate a different decay function :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reference pore-decay (percent). Normalize inside the integral.\np_ref <- function(t) { 15.377 * exp(-0.004 * t) + 1.503 }\n\neffective_pore_time <- function(pfun, T_minutes) {\n  integrate(function(s) pfun(s) / pfun(0), lower = 0, upper = T_minutes)$value\n}\n\npredict_yield_with_decay <- function(P0, T_minutes, p_new = p_ref) {\n  scale_base <- Cref(T_minutes) * (P0 / Pref)\n  ratio <- effective_pore_time(p_new, T_minutes) / effective_pore_time(p_ref, T_minutes)\n  scale_base * ratio\n}\n\n# Convenience: return Gb\npredict_yield_with_decay_Gb <- function(P0, T_minutes) {\n  predict_yield_with_decay(P0, T_minutes) / 1e9\n}\n\npredict_yield_with_decay_Gb(1200, 4320)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.477723\n```\n:::\n:::\n\n\n## Summary\n\nWhile I doubt the MinION fow cells will degrade as quickly as the Flongles, the predicted output for a MinION flow cell (\\~3.5Gb) is far below what I had been previously estimating (30Gb). As such, **I'm going to drop from multiplexing 4 samples per flow cell to 3 samples per flow cell**, to try to get more coverage for each.\n",
    "supporting": [
      "2025_08_14_Flongle_stats_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}