{
  "hash": "b21e51fe0d54aca6e87d18f3ac2be439",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul WGCNA, mRNA and miRNA\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-03-11\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\nWorking with the *A. pulchra* timeseries gene expression (RNA + sRNA) data from E5 Coral project.\n\n[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/12-Apul-miRNA-mRNA-WGCNA.md)\n\nI ran a Weighted Gene Correlation Network Analysis (WGCNA) with both gene and miRNA expression to a) group similarly-expressed sets of genes and/or miRNAs into \"modules\" of coexpression, and b) evaluate correlation of gene expression modules with different physiological and environmental variables.\n\nNote that, unlike my original trials with WGCNA, I variance stabilized the gene counts and miRNA counts *separately* this time, after talking w Ariana about how to prep data appropriately. This didn't have a huge impact on overall trends (which were already driven by the genes, not miRNA), but it really impacted miRNA module placement. When I VST'd everything together almost all miRNA ended up placed in the same module, likely because all the miRNA have relatively low counts. After performing VST separately, WGCNA now places the miRNA across \\~15 modules.\n\n![](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/12-Apul-miRNA-mRNA-WGCNA_files/figure-gfm/unnamed-chunk-31-1.png?raw=true)\n\nWGCNA identified a total of 54 modules of coexpressed genes/miRNA, 19 of which contain miRNA. Roughly half of the miRNA are contained within a single module, one of the larger modules that likely represents housekeeping function. The remaining miRNA are spread out, generally the only miRNA in their modules.\n\n![](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/12-Apul-miRNA-mRNA-WGCNA_files/figure-gfm/unnamed-chunk-34-1.png?raw=true)\n\nIn the above interaction network plot, each module is shown as a node. Modules that contain miRNA are black nodes, while gene-only modules are in grey. A line between two modules indicates the module eigengenes are significantly correlated, with a correlation coefficient magnitude of at least 0.7. Blue shading indicates positive correlation and red indicates negative correlation.\n\nTo look for potential miRNA-target mRNA interactions we're looking for negative correlations where at least one module contains miRNA. I count roughly 20 of these!\n\n![](images/Module-trait-relationship-heatmap.jpg)\n\nRan correlation of modules with physiological and environmental variables, and some interesting stuff popped out! Interestingly, timepoints 2 and 3 have significantly correlated modules, but timepoints 1 and 4 don't. This suggests the influence of timepoint stems largely from the temperature conditions, since a) timepoints 2 and 3 have the most \"extreme\" temperatures (in comparison to annual mean), and b) many of their correlated modules are also significantly correlated with temperature. Interestingly, timepoints 2 and 3 (March and September 2020) are actually extreme in opposite directions. March 2020 was the warmest timepoint and September was the coolest. If the two are correlated with very similar sets of gene modules, that suggests very similar expression pathways are used in response to both heat stress and cold stress in A.pulchra!\n\n![](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/12-Apul-miRNA-mRNA-WGCNA_files/figure-gfm/unnamed-chunk-48-1.png?raw=true)\n\nWe can also plot out the eigengene expression of modules of interest across variables. Above are all the modules significantly correlated withe temperature, plotted across standardized temperature.\n\nCode:\n\nRunning Weighted Gene Correlation Network Analysis (WGCNA) to assess patterns of miRNA-mRNA coexpression in A.pulchra.\n\n\n\n\n\n# Install and load packages\n\n\n::: {.cell inlcude='true'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(WGCNA)\nlibrary(magrittr)\nlibrary(genefilter)\nlibrary(DESeq2)\nlibrary(ggfortify)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(factoextra)\nlibrary(vegan)\nlibrary(dendsort)\nlibrary(ComplexHeatmap)\nlibrary(psych)\nlibrary(igraph)\nlibrary(ggraph)\n```\n:::\n\n\n# Load and prep data\n\nLoad in count matrices for RNAseq.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# raw gene counts data (will filter and variance stabilize)\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\nApul_genes <- as.data.frame(Apul_genes)\n\n# format gene IDs as rownames (instead of a column)\nrownames(Apul_genes) <- Apul_genes$gene_id\nApul_genes <- Apul_genes%>%select(!gene_id)\n\n\n# load and format metadata\nmetadata <- read_csv(\"../../M-multi-species/data/rna_metadata.csv\")%>%select(AzentaSampleName, ColonyID, Timepoint)%>%\n  filter(grepl(\"ACR\", ColonyID))\nmetadata$Sample <- paste(metadata$AzentaSampleName, metadata$ColonyID, metadata$Timepoint, sep = \"_\")\n\ncolonies <- unique(metadata$ColonyID)\n\n# Load physiological data\nphys<-read_csv(\"https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\")%%filter(colony_id_corr %in% colonies)%>%\n  select(colony_id_corr, species, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, AQY, Rd, Ik, Ic, calc.umol.cm2.hr, cells.mgAFDW, prot_mg.mgafdw, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, cre.umol.mgafdw)\n# format timepoint\nphys$timepoint <- gsub(\"timepoint\", \"TP\", phys$timepoint)\n#add column with full sample info\nphys <- merge(phys, metadata, by.x = c(\"colony_id_corr\", \"timepoint\"), by.y = c(\"ColonyID\", \"Timepoint\")) %>%\n  select(-AzentaSampleName)\n  \n\n#add site information into metadata \nmetadata$Site<-phys$site[match(metadata$ColonyID, phys$colony_id_corr)]\n\n\n# Rename gene column names to include full sample info (as in miRNA table)\ncolnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]\n\n# raw miRNA counts (will filter and variance stabilize)\nApul_miRNA <- read.table(file = \"../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt\", header = TRUE, sep = \"\\t\", check.names = FALSE)\n```\n:::\n\n\nEnsure there are no genes or miRNAs with 0 counts across all samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(Apul_genes)\n\nApul_genes<-Apul_genes %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_genes)\n\n# miRNAs\nnrow(Apul_miRNA)\n\nApul_miRNA<-Apul_miRNA %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_miRNA)\n```\n:::\n\n\nRemoving genes with only 0 counts reduced number from 44371 to 35869. Retained all 51 miRNAs.\n\n## Physiology filtering\n\nRun PCA on physiology data to see if there are phys outliers\n\nExport data for PERMANOVA test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest<-as.data.frame(phys)\ntest<-test[complete.cases(test), ]\n```\n:::\n\n\nBuild PERMANOVA model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_test <-prcomp(test%>%select(where(is.numeric)), scale=TRUE, center=TRUE)\nfviz_eig(scaled_test)\n\n# scale data\nvegan <- scale(test%>%select(where(is.numeric)))\n\n# PerMANOVA \npermanova<-adonis2(vegan ~ timepoint*site, data = test, method='eu')\npermanova\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npca1<-ggplot2::autoplot(scaled_test, data=test, frame.colour=\"timepoint\", loadings=FALSE,  colour=\"timepoint\", shape=\"site\", loadings.label.colour=\"black\", loadings.colour=\"black\", loadings.label=FALSE, frame=FALSE, loadings.label.size=5, loadings.label.vjust=-1, size=5) + \n  geom_text(aes(x = PC1, y = PC2, label = paste(colony_id_corr, timepoint)), vjust = -0.5)+\n  theme_classic()+\n   theme(legend.text = element_text(size=18), \n         legend.position=\"right\",\n        plot.background = element_blank(),\n        legend.title = element_text(size=18, face=\"bold\"), \n        axis.text = element_text(size=18), \n        axis.title = element_text(size=18,  face=\"bold\"));pca1\n```\n:::\n\n\nRemove ACR-173, timepoint 3 sample from analysis. This is Azenta sample 1B2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes <- Apul_genes%>%\n  select(!`1B2_ACR-173_TP3`)\n\nApul_miRNA <- Apul_miRNA%>%\n  select(!`1B2_ACR-173_TP3`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B2_ACR-173_TP3\")\n```\n:::\n\n\nWe also do not have phys data for colony 1B9 ACR-265 at TP4, so I'll remove that here as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes <- Apul_genes%>%\n  select(!`1B9_ACR-265_TP4`)\n\nApul_miRNA <- Apul_miRNA%>%\n  select(!`1B9_ACR-265_TP4`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B9_ACR-265_TP4\")\n```\n:::\n\n\n## pOverA filtering\n\n*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Here, we are using a pOverA of 0.1. This is because we have 40 samples with a minimum of n=4 samples per timepoint per site. Therefore, we will accept genes that are present in 4/40 = 0.1 of the samples because we expect different expression by life stage. We are further setting the minimum count of genes and miRNA to 10, such that 12.5% of the samples must have a gene count of \\>10 in order for the gene to remain in the data set.\n\nFilter in the package \"genefilter\". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.\n\ngenes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilt <- filterfun(pOverA(0.1,10))\n\n#create filter for the counts data\ngfilt <- genefilter(Apul_genes, filt)\n\n#identify genes to keep by count filter\ngkeep <- Apul_genes[gfilt,]\n\n#identify genes to keep by count filter\ngkeep <- Apul_genes[gfilt,]\n\n#identify gene lists\ngn.keep <- rownames(gkeep)\n\n#gene count data filtered in PoverA, P percent of the samples have counts over A\nApul_genes_filt <- as.data.frame(Apul_genes[which(rownames(Apul_genes) %in% gn.keep),])\n\n#How many rows do we have before and after filtering?\nnrow(Apul_genes) #Before\nnrow(Apul_genes_filt) #After\n```\n:::\n\n\nWe had 35869 genes before, and 23459 genes after filtering.\n\nmiRNA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmifilt <- filterfun(pOverA(0.1,10))\n\n#create filter for the counts data\nmifilt <- genefilter(Apul_miRNA, mifilt)\n\n#identify genes to keep by count filter\nmikeep <- Apul_miRNA[mifilt,]\n\n#identify genes to keep by count filter\nmikeep <- Apul_miRNA[mifilt,]\n\n#identify gene lists\nmi.keep <- rownames(mikeep)\n\n#gene count data filtered in PoverA, P percent of the samples have counts over A\nApul_miRNA_filt <- as.data.frame(Apul_miRNA[which(rownames(Apul_miRNA) %in% mi.keep),])\n\n#How many rows do we have before and after filtering?\nnrow(Apul_miRNA) #Before\nnrow(Apul_miRNA_filt) #After\n```\n:::\n\n\nOf our original 51 miRNAs, 43 are retained.\n\n## Assign metadata and arrange order of columns\n\nOrder metadata the same as the column order in the gene matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist<-colnames(Apul_genes_filt)\nlist<-as.factor(list)\n\nmetadata$Sample<-as.factor(metadata$Sample)\n\n# Re-order the levels\nmetadata$Sample <- factor(as.character(metadata$Sample), levels=list)\n# Re-order the data.frame\nmetadata_ordered <- metadata[order(metadata$Sample),]\nmetadata_ordered$Sample\n\n# Make sure the miRNA colnames are also in the same order as the gene colnames\nApul_miRNA_filt <- Apul_miRNA_filt[, colnames(Apul_genes_filt)]\n```\n:::\n\n\nMetadata and gene count matrix are now ordered the same.\n\n## Conduct variance stabilized transformation\n\nVST should be performed on our two input datasets (gene counts and miRNA counts) separately\n\n### Genes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_genes <- estimateSizeFactors(dds_genes) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_genes)) #View size factors\n\nall(sizeFactors(SF.dds_genes)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes <- vst(dds_genes, blind=FALSE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size\nhead(assay(vsd_genes), 3) #view transformed gene count data for the first three genes in the dataset.  \n```\n:::\n\n\n#### PCA\n\nKeep in mind this is of both the genes and miRNAs. since there are vastly more genes than miRNAs, the PCA will be dictated by genes. for miRNas alone, see `03.10`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(vsd_genes, intgroup = c(\"ColonyID\"))\nplotPCA(vsd_genes, intgroup = c(\"Timepoint\"))\n```\n:::\n\n\n#### Sample clustering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsampleDists_genes <- dist(t(assay(vsd_genes))) #calculate distance matrix\nsampleDistMatrix_genes <- as.matrix(sampleDists_genes) #distance matrix\nrownames(sampleDistMatrix_genes) <- colnames(vsd_genes) #assign row names\ncolnames(sampleDistMatrix_genes) <- NULL #assign col names\ncolors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255) #assign colors\n\npht_genes <- pheatmap(sampleDistMatrix_genes, #plot matrix\n         clustering_distance_rows=sampleDists_genes, #cluster rows\n         clustering_distance_cols=sampleDists_genes, #cluster columns\n         col=colors) #set colors\n\nprint(pht_genes)\n```\n:::\n\n\n### miRNA\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_miRNA <- estimateSizeFactors(dds_miRNA) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_miRNA)) #View size factors\n\nall(sizeFactors(SF.dds_miRNA)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=FALSE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size. Using varianceStabilizingTransformation() instead of vst() because few input genes\nhead(assay(vsd_miRNA), 3) #view transformed gene count data for the first three genes in the dataset.  \n```\n:::\n\n\n#### PCA\n\nKeep in mind this is of both the genes and miRNAs. since there are vastly more genes than miRNAs, the PCA will be dictated by genes. for miRNas alone, see `03.10`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotPCA(vsd_miRNA, intgroup = c(\"ColonyID\"))\nplotPCA(vsd_miRNA, intgroup = c(\"Timepoint\"))\n```\n:::\n\n\n#### Sample clustering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsampleDists_miRNA <- dist(t(assay(vsd_miRNA))) #calculate distance matrix\nsampleDistMatrix_miRNA <- as.matrix(sampleDists_miRNA) #distance matrix\nrownames(sampleDistMatrix_miRNA) <- colnames(vsd_miRNA) #assign row names\ncolnames(sampleDistMatrix_miRNA) <- NULL #assign col names\ncolors <- colorRampPalette( rev(brewer.pal(9, \"Blues\")) )(255) #assign colors\n\npht_miRNA <- pheatmap(sampleDistMatrix_miRNA, #plot matrix\n         clustering_distance_rows=sampleDists_miRNA, #cluster rows\n         clustering_distance_cols=sampleDists_miRNA, #cluster columns\n         col=colors) #set colors\n\nprint(pht_miRNA)\n```\n:::\n\n\n## Combine counts data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract variance stabilized counts as dataframes\ndatExpr_genes <- as.data.frame(t(assay(vsd_genes)))\ndatExpr_miRNA <- as.data.frame(t(assay(vsd_miRNA)))\n\n# Double check the row names (sample names) are in same order\nrownames(datExpr_genes) == rownames(datExpr_miRNA)\n\n# Combine vst gene counts and vst miRNA counts by rows (sample names)\ndatExpr <- cbind(datExpr_genes, datExpr_miRNA)\n```\n:::\n\n\n# Outlier checks\n\nLook for outliers by examining tree of samples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsampleTree = hclust(dist(datExpr), method = \"average\");\nplot(sampleTree, main = \"Sample clustering to detect outliers: genes\", sub=\"\", xlab=\"\", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)\n```\n:::\n\n\nSoft threshold selection. The soft thresholding power (Î²) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallowWGCNAThreads()\n# # Choose a set of soft-thresholding powers\npowers <- c(seq(from = 1, to=19, by=2), c(21:30)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20\n# \n# # Call the network topology analysis function\nsft <- pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)\n```\n:::\n\n\nPlot the results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsizeGrWindow(9, 5)\npar(mfrow = c(1,2));\ncex1 = 0.9;\n# # # Scale-free topology fit index as a function of the soft-thresholding power\nplot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],\n      xlab=\"Soft Threshold (power)\",ylab=\"Scale Free Topology Model Fit,signed R^2\",type=\"n\",\n     main = paste(\"Scale independence\"));\n text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],\n     labels=powers,cex=cex1,col=\"red\");\n# # # this line corresponds to using an R^2 cut-off\n abline(h=0.9,col=\"red\")\n# # # Mean connectivity as a function of the soft-thresholding power\n plot(sft$fitIndices[,1], sft$fitIndices[,5],\n     xlab=\"Soft Threshold (power)\",ylab=\"Mean Connectivity\", type=\"n\",\n     main = paste(\"Mean connectivity\"))\n text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col=\"red\")\n```\n:::\n\n\nI used a scale-free topology fit index **R\\^2 of 0.9**. The lowest recommended R\\^2 by Langfelder and Horvath is 0.8. I chose 0.9 because we want to use the smallest soft thresholding power that maximizes with model fit. It appears that our **soft thresholding power is 5** because it is the lowest power above the R\\^2=0.9 threshold that maximizes with model fit. I will use a **signed network**.\n\n# WGCNA\n\nNow we're ready to run WGCNA!\n\n\n::: {.cell hash='2025_03_11_timeseries_WGCNA_cache/html/unnamed-chunk-24_53cac8f40db9ed20ae4a24d8b305d189'}\n\n```{.r .cell-code}\npicked_power = 5\ntemp_cor <- cor       \ncor <- WGCNA::cor         # Force it to use WGCNA cor function (fix a namespace conflict issue)\nnetwk_Apul <- blockwiseModules(datExpr,                # <= input here\n\n                          # == Adjacency Function ==\n                          power = picked_power,                # <= power here\n                          networkType = \"signed\",\n\n                          # == Tree and Block Options ==\n                          deepSplit = 2,\n                          pamRespectsDendro = F,\n                          # detectCutHeight = 0.75,\n                          minModuleSize = 30,\n                          maxBlockSize = 5000,\n\n                          # == Module Adjustments ==\n                          reassignThreshold = 1e-6,\n                          mergeCutHeight = 0.15,\n\n                          # == TOM == Archive the run results in TOM file (saves time)\n                          saveTOMs = F,\n                          saveTOMFileBase = \"ER\",\n\n                          # == Output Options\n                          numericLabels = T,\n                          verbose = 3)\n\n\ncor <- temp_cor     # Return cor function to original namespace\n```\n:::\n\n\nTake a look at dendrogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Convert labels to colors for plotting\nmergedColors = labels2colors(netwk_Apul$colors)\nlabels = table(netwk_Apul$colors)\nlabels\n\n# Plot the dendrogram and the module colors underneath\n\nplotDendroAndColors(\n  netwk_Apul$dendrograms[[1]],\n  mergedColors[netwk_Apul$blockGenes[[1]]],\n  \"Module colors\",\n  dendroLabels = FALSE,\n  hang = 0.03,\n  addGuide = TRUE,\n  guideHang = 0.05 )\n```\n:::\n\n\nShow module number before and after merging.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(table(netwk_Apul$unmergedColors))\nlength(table(netwk_Apul$colors))\n```\n:::\n\n\nThere are 56 modules before merging to 85% similarity and 54 after.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMEs<-netwk_Apul$MEs\nmoduleLabels<-netwk_Apul$colors\nmoduleColors <- labels2colors(netwk_Apul$colors)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get Module Eigengenes per cluster\n# MEs0_Apul <- moduleEigengenes(datExpr, mergedColors)$eigengenes\nmME_Apul <- moduleEigengenes(datExpr, mergedColors)$eigengenes\n\n# Add treatment names\n# MEs0_Apul$sample = row.names(MEs0_Apul)\nmME_Apul$sample = row.names(mME_Apul)\n\n# Join metadata to add timepoint to mME_Apul\nmME_Apul <- mME_Apul %>%\n  left_join(metadata, by = c(\"sample\" = \"Sample\"))\n\n# Order samples by timepoint\ntimepoint_order <- c(\"TP1\", \"TP2\", \"TP3\", \"TP4\") # Specify the desired order of timepoints\nmME_Apul <- mME_Apul %>%\n  mutate(sample = factor(sample, levels = metadata$Sample[order(match(metadata$Timepoint, timepoint_order))]))\n\n# Plot heatmap\nmME_Apul %>% \n  pivot_longer(cols = -c(sample, Timepoint), # Ensure only eigengenes are reshaped\n               names_to = \"module\",\n               values_to = \"value\") %>%\n  ggplot(., aes(x = sample, y = name, fill = value)) +\n  geom_tile() +\n  theme_bw() +\n  scale_fill_gradient2(\n    low = \"blue\",\n    high = \"red\",\n    mid = \"white\",\n    midpoint = 0,\n    limit = c(-1,1)\n  ) +\n  theme(axis.text.x = element_text(angle = 90)) +\n  labs(title = \"Module-trait Relationships\", y = \"Modules\", fill = \"corr\")\n```\n:::\n\n\n# Characterize gene/miRNA composition of modules\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grab gene names and corresponding module colors\nmodule_info <- data.frame(\n  gene = colnames(datExpr),\n  module = moduleLabels\n)\n#Add ME to all the names\nmodule_info$module <- paste0(\"ME\", module_info$module)\n\nhead(module_info)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to calculate the proportion of mRNAs (genes with \"FUN\" in ID)\ncalculate_mRNA_proportion <- function(genes) {\n  total_genes <- length(genes)\n  mRNA_count <- sum(grepl(\"FUN\", genes))\n  \n  # Proportion of mRNAs\n  proportion_mRNA <- mRNA_count / total_genes\n  return(proportion_mRNA)\n}\n\n# Since there are so few miRNA, it may be more appropriate to calculate # of miRNA contained in a given module\ncalculate_miRNA_num <- function(genes) {\n  total_genes <- length(genes)\n  miRNA_count <- sum(grepl(\"Cluster\", genes))\n  return(miRNA_count)\n}\n\n# Apply the functions to each module\nmodule_mRNA_proportion <- tapply(module_info$gene, \n                                 module_info$module, \n                                 calculate_mRNA_proportion)\n\nmodule_miRNA_count <- tapply(module_info$gene,\n                             module_info$module,\n                             calculate_miRNA_num)\n\n# View the proportions\n\nlength(module_miRNA_count[module_miRNA_count > 0])\n\nmodule_miRNA_count\n```\n:::\n\n\n19 of the 54 modules contain miRNA.\n\nModule 0 contains almost half of the miRNA that were retained post-filtering (18/43). Keep in mind that the smaller the module number, the more genes it contains, so ME0 is one of the largest modules of coexpressed genes, and likely represents housekeeping function. It's thus not surprising that many miRNAs also grouped there!\n\nThe remaining 25 miRNA were quite spread out, most were the only miRNA in their module, with a handful of modules containing 2-3 coexpressed miRNA.\n\nPlot\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Make df of module sizes\nmodule_sizes_df<-as.data.frame(labels)\ncolnames(module_sizes_df) <- c(\"module\", \"size\")\nmodule_sizes_df$module<-paste0(\"ME\", module_sizes_df$module)\n\n# df of num. miRNA in each module\nmodule_miRNA_count_df <- as.data.frame(module_miRNA_count)\nmodule_miRNA_count_df$module <- rownames(module_miRNA_count_df)\n\n# Combine and add column for num of genes in each module\nmodule_composition <- left_join(module_sizes_df, module_miRNA_count_df, by=\"module\")\nmodule_composition$module_gene_count <- module_composition$size - module_composition$module_miRNA_count\n\n# order by module size\nmodule_composition <- module_composition %>%\n  arrange(desc(size)) %>%\n  mutate(module = factor(module, levels = module))\n\n# Convert to long format for stacking\nmodule_composition_long <- module_composition %>%\n  pivot_longer(cols = c(module_gene_count, module_miRNA_count), \n               names_to = \"type\", \n               values_to = \"count\") %>%\n  mutate(type = factor(type, levels = c(\"module_gene_count\", \"module_miRNA_count\")))  # Order for stacking\nmodule_composition$type <- \"\"\n\n# Plot\nggplot(module_composition_long, aes(x = module, y = count, fill = type)) +\n  geom_bar(stat = \"identity\") +\n  geom_text(data = module_composition, aes(x = module, y = size + 60, \n                                     label = module_miRNA_count), size = 3) +  # Label miRNA count\n  scale_fill_manual(values = c(\"module_gene_count\" = \"steelblue\", \"module_miRNA_count\" = \"orange\"),\n                    labels = c(\"Genes\", \"miRNAs\")) +\n  labs(x = \"Module\", y = \"Total Module Size\", title = \"Stacked Barplot of Genes and miRNAs\") +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.title = element_blank())\n```\n:::\n\n\nLarger modules seem to be more likely to contain miRNA, which makes sense intuitively. However, the low number of total miRNA in comparison to the number of genes present means that miRNA don't make up an appreciable proportion of any module.\n\n# Correlate modules to each other\n\nmiRNAs are expected to either facilitate mRNA degradation or repress mRNA translation, both of which would result in a negative miRNA-mRNA relationship (more of an miRNA means less of its target mRNA(s)). WGCNA modules only group genes with similar expression patterns, so these inverse relationships would not be present within a single module. Instead, we need to find modules that are inversely related (have a strong, negative correlation).\n\nCompute correlations between modules\n\n-   which correlation coefficient to use? I think WGCNA is based off of Pearson's correlation coefficient...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbtwn_module_cor <- corr.test(MEs, method = \"pearson\", adjust = \"BH\")\n\n# Extract correlation values and p-values\nbtwn_module_cor_matrix <- btwn_module_cor$r  # Correlation coefficients\nbtwn_module_p_matrix <- btwn_module_cor$p  # Adjusted p-values\n```\n:::\n\n\nConstruct network\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set correlation and significance thresholds\ncor_threshold <- 0.7  # Adjust based on desired stringency\np_threshold <- 0.05\n\n# Convert correlation matrix into an edge list\nsignificant_edges <- which(abs(btwn_module_cor_matrix) > cor_threshold & btwn_module_p_matrix < p_threshold, arr.ind = TRUE)\n\nedge_list <- data.frame(\n  module_A = rownames(btwn_module_cor_matrix)[significant_edges[,1]],\n  module_B = colnames(btwn_module_cor_matrix)[significant_edges[,2]],\n  correlation = btwn_module_cor_matrix[significant_edges]\n)\n\n# Construct network graph\nnetwork <- graph_from_data_frame(edge_list, directed = FALSE)\n\n# module_mRNA_proportion<-as.data.frame(module_mRNA_proportion)\n# \n# V(apul_network)$prop_mrna <- module_mRNA_proportion$module_mRNA_proportion[match(V(apul_network)$name, rownames(module_mRNA_proportion))]\n\n# Add miRNA presence/absence to the network nodes\nV(network)$has_miRNA <- ifelse(\n  module_miRNA_count_df$module %in% V(network)$name & module_miRNA_count_df$module_miRNA_count > 0, \n  \"Yes\", \"No\"\n)\n```\n:::\n\n\nPlot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot1<-ggraph(network, layout = \"fr\") +  # Force-directed layout\n  geom_edge_link(aes(edge_color = correlation), width = 2, show.legend = TRUE) +\n  #geom_edge_link(aes(edge_alpha = correlation), show.legend = TRUE, width=2) +\n  #geom_node_point(aes(colour=prop_mrna), size = 5) +\n  #scale_colour_gradient(name=\"Prop. mRNA\", low = \"purple\", high = \"cyan3\")+\n  geom_node_point(aes(color = has_miRNA), size = 3) +  # Color nodes based on miRNA presence\n  scale_edge_color_gradient2(low = \"red\", mid = \"yellow\", high = \"blue\", midpoint = 0, name = \"Correlation\") +  \n  scale_color_manual(values = c(\"Yes\" = \"black\", \"No\" = \"grey\"), name = \"miRNA Present\") +\n  geom_node_text(aes(label = name), repel = TRUE, size = 4) +\n  theme_void() +\n  labs(title = \"A. pulchra mRNA-CpG Network\");plot1\n```\n:::\n\n\nCool! In the above interaction network plot, each module is shown as a node. Modules that contain miRNA are black nodes, while gene-only modules are in grey. A line between two modules indicates the module eigengenes are significantly correlated, with a correlation coefficient magnitude of at least 0.7. Blue shading indicates positive correlation and red indicates negative correlation.\n\nTo look for potential miRNA-target mRNA interactions we're looking for negative correlations where at least one module contains miRNA. I count roughly 20 of these!\n\n# Correlate to traits\n\nEnsure we've removed sample from expression data that is not present in physiological data. 1B9\n\n\n::: {.cell}\n\n```{.r .cell-code}\nphys<-phys%>%\n  filter(!Sample==\"1B2_ACR-173_TP3\")%>%\n  filter(!Sample==\"1B9_ACR-265_TP4\")\n\nsetdiff(metadata_ordered$Sample, phys$Sample)\n\n#all have 38 observations \n```\n:::\n\n\nCreate a physiological/factor dataset with sample in rows and phys data in columns (row name = Azenta sample name)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# phys$AzentaSampleName<-metadata_ordered$AzentaSampleName[match(phys$Sample, metadata_ordered$Sample)]\n\ntraits<-phys%>%\n  select(Sample, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, Rd, Ik, Ic, AQY, cells.mgAFDW, Total_Chl, Ratio_AFDW.mg.cm2, Total_Chl_cell)\n\n#time point\n#site\ntraits<-traits%>%\n  mutate(site=gsub(\"Mahana\", \"1\", site)) %>%\n  mutate(site=gsub(\"Manava\", \"2\", site))%>%\n  mutate(timepoint=gsub(\"TP\", \"\", timepoint))\n\ntraits$timepoint<-as.numeric(traits$timepoint)\ntraits$site<-as.numeric(traits$site)\n\ntraits<-as.data.frame(traits)\nrownames(traits)<-traits$Sample\n\ndatTraits<-traits%>%select(!Sample)\n\n#datTraits<-datTraits%>%select(!Timepoint)\n```\n:::\n\n\nAdd in temperature and light information for each time point from physiology manuscript. Note these have already been standardized for use in WGCNA.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenv<-read_csv(\"https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/environment_characteristics_RDA.csv\") %>%\n  select(mean_Temp_mean, mean_solar_rad_kwpm2_mean, cumulative_rainfall_mm_mean, timepoint) %>%\n  mutate(timepoint=if_else(timepoint==\"timepoint1\", \"1\",\n                           if_else(timepoint==\"timepoint2\", \"2\",\n                                   if_else(timepoint==\"timepoint3\", \"3\", \"4\")))) %>%\n  mutate(timepoint=as.numeric(timepoint))\n\n#merge into datTraits\n\ndatTraits<-left_join(datTraits, env)\nrownames(datTraits)<-traits$Sample\n\nstr(datTraits)\n```\n:::\n\n\nFinally, we want to identify modules that are significantly correlated with timepoint. Since correlation analysis wouldn't identify non-linear relationships, we need to encode timepoint as 4 separate binomial variables (timepoint1 -- yes/no?, timepoint2 -- yes/no?, etc.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatTraits <- datTraits %>%\n  mutate(\n    timepoint1 = as.integer(timepoint == 1),\n    timepoint2 = as.integer(timepoint == 2),\n    timepoint3 = as.integer(timepoint == 3),\n    timepoint4 = as.integer(timepoint == 4)\n  ) %>% select(!timepoint)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnGenes = ncol(datExpr)\nnSamples = nrow(datExpr)\n\nnGenes\nnSamples\n```\n:::\n\n\nGenerate labels for module eigengenes as numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMEs0 = moduleEigengenes(datExpr, moduleLabels, softPower=5)$eigengenes\nMEs = orderMEs(MEs0)\nnames(MEs)\n```\n:::\n\n\nCorrelations of traits with eigengenes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoduleTraitCor = cor(MEs, datTraits, use = \"p\");\nmoduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);\nColors=sub(\"ME\",\"\", names(MEs))\n\nmoduleTraitTree = hclust(dist(t(moduleTraitCor)), method = \"average\")\n\n# pdf(file=\"D-Apul/output/11.00-Apul-WGCNA/ModuleTraitClusterTree.pdf\")\nplot(moduleTraitTree)\n# dev.off()\n```\n:::\n\n\nCorrelations of genes with eigengenes. Calculate correlations between ME's and physiology/environmental variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoduleGeneCor=cor(MEs,datExpr)\nmoduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);\n```\n:::\n\n\nCalculate kME values (module membership).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatKME = signedKME(datExpr, MEs, outputColumnName = \"kME\")\nhead(datKME)\n```\n:::\n\n\nGenerate a complex heatmap of module-trait relationships.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#bold sig p-values\n#dendrogram with WGCNA MEtree cut-off\n#colored y-axis\n\n#Create list of pvalues for eigengene correlation with specific physiology traits or environmental conditions\nheatmappval <- signif(moduleTraitPvalue, 1)\n\n#Make list of heatmap row colors\nhtmap.colors <- names(MEs)\nhtmap.colors <- gsub(\"ME\", \"\", htmap.colors)\n\nrow_dend = dendsort(hclust(dist(moduleTraitCor)))\ncol_dend = dendsort(hclust(dist(t(moduleTraitCor))))\n\n#pdf(file = \"../output/12-Apul-miRNA-mRNA-WGCNA/Module-trait-relationship-heatmap.pdf\", height = 14, width = 8)\nHeatmap(moduleTraitCor, name = \"Eigengene\", row_title = \"Gene Module\", column_title = \"Module-Trait Eigengene Correlation\", \n        col = blueWhiteRed(50), \n        row_names_side = \"left\", \n        #row_dend_side = \"left\",\n        width = unit(5, \"in\"), \n        height = unit(8.5, \"in\"), \n        #column_dend_reorder = TRUE, \n        #cluster_columns = col_dend,\n        row_dend_reorder = TRUE,\n        #column_split = 6,\n        row_split=3,\n        #column_dend_height = unit(.5, \"in\"),\n        #column_order = lifestage_order, \n        cluster_rows = row_dend, \n        row_gap = unit(2.5, \"mm\"), \n        border = TRUE,\n        cell_fun = function(j, i, x, y, w, h, col) {\n        if(heatmappval[i, j] < 0.05) {\n            grid.text(sprintf(\"%s\", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = \"bold\"))\n        }\n        else {\n            grid.text(sprintf(\"%s\", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = \"plain\"))\n        }},\n        column_names_gp =  gpar(fontsize = 12, border=FALSE),\n        column_names_rot = 35,\n        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))\n#draw(ht)\n#dev.off()\n```\n:::\n\n\nThis plot is cool, but I'm a little skeptical of the results. No modules show significant relationship with timepoint, despite the PCAs showing a pretty clear clustering by timepoint...\n\nUpdate 3/5/25: Cleared up why timepoint isn't showing significant relationship, has to do with timepoint being a categorical variable that is encoded numerically (1-4) and this correlation analysis not picking up non-linear relationships. However, incorporation of environmental variables (temp, solar, etc.) for each timepoint essentially provides a set of time-dependent continuous variables, and these *are* showing significant relationships! mean temperature in particular shows significant correlation with *10* modules, including several *highly* significant correlations! Super cool!\n\nUpdate 3/11/25: Encoded timepoints as 4 separate binomial columns, so that should take care of the original issue with numerically encoding timepoint. Interestingly, timepoints 2 and 3 have significantly correlated modules, but timepoints 1 and 4 don't. This suggests the influence of timepoint stems largely from the temperature conditions, since a) timepoints 2 and 3 have the most \"extreme\" temperatures (in comparison to annual mean), and b) many of their correlated modules are also significantly correlated with temperature. Interestingly, timepoints 2 and 3 (March and September 2020) are actually extreme in opposite directions. March 2020 was the warmest timepoint and September was the coolest. If the two are correlated with very similar sets of gene modules, that suggests very similar expression pathways are used in response to both heat stress and cold stress in A.pulchra!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract modules with significant correlations\nheatmappval_df <- as.data.frame(heatmappval) \n\n# For mean temp\nMEs_signif_temp <- rownames(heatmappval_df[heatmappval_df$mean_Temp_mean < 0.05,])\n```\n:::\n\n\nWe can also compare to our module interaction plot to find modules that are both correlated with temperature and potentially involved in miRNA-mRNA interactions! Modules 19, 42, 1, 6, 15, 7, 2, are both significantly correlated with temperature *and* have negative module-module interactions that involve at least 1 module that contains miRNA.\n\n# Plot eigengene values\n\nView module eigengene data and make dataframe for Strader plots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(MEs)\nnames(MEs)\nEigen_MEs <- MEs\nEigen_MEs$AzentaSampleName <- rownames(Eigen_MEs)\nhead(Eigen_MEs)\n\nplotTraits<-datTraits\nplotTraits$AzentaSampleName <- rownames(plotTraits)\n\nEigen_MEs<-Eigen_MEs%>%\n  droplevels() #drop unused level\n\ndim(Eigen_MEs)\nhead(Eigen_MEs)\n```\n:::\n\n\nPlot mean module eigengene for each module.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#convert wide format to long format for plotting  \nstr(Eigen_MEs)\n\nplot_MEs <- Eigen_MEs %>%\n  pivot_longer(\n    cols = where(is.numeric),  # Select only numeric columns\n    names_to = \"Module\",       # Name for the new column containing the column names\n    values_to = \"Mean\"         # Name for the new column containing the values\n  )\n\nstr(plot_MEs)\n\n#join with phys data \nplot_MEs<-left_join(plot_MEs, plotTraits)\n\nexpression_plots<-plot_MEs%>%\n  group_by(Module) %>%\n  \n  ggplot(aes(x=mean_Temp_mean, y=Mean)) +\n  facet_wrap(~ Module)+\n  geom_point()+\n  # geom_smooth(method=\"lm\")+\n  # The loess method can capture nonlinear trends\n  geom_smooth(method=\"loess\")+\n  #ylim(-0.5,1) +\n  geom_hline(yintercept = 0, linetype=\"dashed\", color = \"grey\")+\n  theme_bw() + \n  theme(axis.text.x=element_text(angle = 45, hjust=1, size = 12), #set x-axis label size\n        axis.title.x=element_text(size = 14), #set x-axis title size\n        axis.ticks.x=element_blank(), #No x-label ticks\n        #axis.title.y=element_blank(), #No y-axis title\n        axis.text.y=element_text(size = 14), #set y-axis label size, \n        panel.border = element_rect(color = \"black\", fill = NA, size = 1), #set border\n        panel.grid.major = element_blank(), #Set major gridlines\n        panel.grid.minor = element_blank(), #Set minor gridlines\n        axis.line = element_line(colour = \"black\"), #Set axes color\n        plot.background=element_blank(),\n        plot.title = element_text(size=22)); expression_plots\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Now just plot the modules that are significantly correlated with temp\nplot_MEs_signif_temp <- plot_MEs %>%\n    filter(Module %in% MEs_signif_temp)\n\n\nexpression_plots<-plot_MEs_signif_temp%>%\n  group_by(Module) %>%\n  \n  ggplot(aes(x=mean_Temp_mean, y=Mean)) +\n  facet_wrap(~ Module)+\n  geom_point()+\n  # geom_smooth(method=\"lm\")+\n  # the loess method can capture nonlinear trends\n  geom_smooth(method=\"loess\")+\n  #ylim(-0.5,1) +\n  geom_hline(yintercept = 0, linetype=\"dashed\", color = \"grey\")+\n  theme_bw() + \n  theme(axis.text.x=element_text(angle = 45, hjust=1, size = 12), #set x-axis label size\n        axis.title.x=element_text(size = 14), #set x-axis title size\n        axis.ticks.x=element_blank(), #No x-label ticks\n        #axis.title.y=element_blank(), #No y-axis title\n        axis.text.y=element_text(size = 14), #set y-axis label size, \n        panel.border = element_rect(color = \"black\", fill = NA, size = 1), #set border\n        panel.grid.major = element_blank(), #Set major gridlines\n        panel.grid.minor = element_blank(), #Set minor gridlines\n        axis.line = element_line(colour = \"black\"), #Set axes color\n        plot.background=element_blank(),\n        plot.title = element_text(size=22)); expression_plots\n```\n:::\n\n\n# Export to Cytoscape\n\nExport modules of interest for network visualization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMEs_signif_temp\n```\n:::\n\n\nNote that, due to the size of many modules, it's probably most practical to export modules individually (unless interested in in connections between modules)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# # Recalculate topological overlap if needed\n# TOM = TOMsimilarityFromExpr(datExpr, power = 5);\n#   # Read in the annotation file\n# annot = datTraits;\n# for(i in seq_along(MEs_signif_temp)) {\n\n#   # Select modules\n#   modules = MEs_signif_temp[i];\n#   # Select module probes\n#   probes = names(datExpr)\n#   inModule = is.finite(match(moduleLabels, modules));\n#   modProbes = probes[inModule];\n#   # modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];\n#   # Select the corresponding Topological Overlap\n#   modTOM = TOM[inModule, inModule];\n#   dimnames(modTOM) = list(modProbes, modProbes)\n#   # Export the network into edge and node list files Cytoscape can read\n#   cyt = exportNetworkToCytoscape(modTOM,\n#     edgeFile = paste(\"CytoscapeInput-edges-\", paste(modules, collapse=\"-\"), \".txt\", sep=\"\"),\n#     nodeFile = paste(\"CytoscapeInput-nodes-\", paste(modules, collapse=\"-\"), \".txt\", sep=\"\"),\n#     weighted = TRUE,\n#     threshold = 0.02,\n#     nodeNames = modProbes,\n#     # altNodeNames = modGenes,\n#     nodeAttr = moduleLabels[inModule]);\n# }\n\n# Recalculate topological overlap if needed\n  TOM = TOMsimilarityFromExpr(datExpr, power = 5);\n  # Read in the annotation file\n  annot = datTraits;\n  # Select modules\n  modules = \"45\";\n  # Select module probes\n  probes = names(datExpr)\n  inModule = is.finite(match(moduleLabels, modules));\n  modProbes = probes[inModule];\n  # modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];\n  # Select the corresponding Topological Overlap\n  modTOM = TOM[inModule, inModule];\n  dimnames(modTOM) = list(modProbes, modProbes)\n  # Export the network into edge and node list files Cytoscape can read\n  cyt = exportNetworkToCytoscape(modTOM,\n    edgeFile = paste(\"CytoscapeInput-edges-\", paste(modules, collapse=\"-\"), \".txt\", sep=\"\"),\n    nodeFile = paste(\"CytoscapeInput-nodes-\", paste(modules, collapse=\"-\"), \".txt\", sep=\"\"),\n    weighted = TRUE,\n    threshold = 0.02,\n    nodeNames = modProbes,\n    # altNodeNames = modGenes,\n    nodeAttr = moduleLabels[inModule]);\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Move cytoscape files to output directory\nmv ./CytoscapeInput* ../output/12-Apul-miRNA-mRNA-WGCNA\n\n```\n:::\n\n\nTo load network to Cytoscape:\n\n1.  File -\\> Import -\\> Network from File...\n\n2.  Select Edges file (created above)\n\n3.  Assign fromNode to \"Source Node,\" toNode to \"Target Node,\" weight to \"Edge Attribute,\" and direction to \"Interaction Type\"\n\n4.  Once netwrok is loaded, can manipulate/style as desired.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print session info\nsessioninfo::session_info()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}