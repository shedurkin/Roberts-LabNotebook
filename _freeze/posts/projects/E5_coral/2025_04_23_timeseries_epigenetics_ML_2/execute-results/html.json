{
  "hash": "1c3da4545dce83e6aea466fab7a2d8d9",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul, epigenetic features to predict expression. Machine learning -- Part 2\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-04-23\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\n[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22.2-Apul-multiomic-machine-learning.Rmd)\n\n[Rendered Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22.2-Apul-multiomic-machine-learning.md)\n\nApplying ML model using multiomic predictors -- miRNA + lncRNA + methylation as predictors of gene expression. This time, instead of reducing the dimensionality of all sets using PCs, I'm using vsd-transformed miRNA/lncRNA/CpG counts as predictors, and vsd-transformed gene counts as responses.\n\nExcluding the dimensionality-reduction makes the model training much more computationally intensive, so I only ran it for the smaller gene sets (Host biomass, ATP production GO terms, Energy usage/storage GO terms).\n\nInputs:\n\n-   RNA counts matrix (raw): `../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv`\n\n-   Gene sets of interest: `../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/`\n\n-   sRNA/miRNA counts matrix (raw): `../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt`\n\n-   lncRNA counts matrix (raw): `../output/08-Apul-lncNRA/counts.txt`\n\n-   WGBS data (processed): Performed in `/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/`, data in [large-file storage](https://gannet.fish.washington.edu/seashell/bu-github/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/).\n\n-   sample metadata: `../../M-multi-species/data/rna_metadata.csv`\n\n# 1 Set up\n\n# 2 Load libraries\n\n``` r\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(DESeq2)\nlibrary(igraph)\nlibrary(psych)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(WGCNA)\nlibrary(edgeR)\nlibrary(reshape2)\nlibrary(ggcorrplot)\nlibrary(corrplot)\nlibrary(rvest)\nlibrary(purrr)\nlibrary(pheatmap)\nlibrary(glmnet)\nlibrary(caret)\nlibrary(factoextra)\nlibrary(vegan)\nlibrary(ggfortify)\nlibrary(genefilter)\nlibrary(scales)\n```\n\nThe model includes random processes, so set a seed for reproducability. Note: for final results, should we consider bootstrapping to ensure reported results are representative?\n\n``` r\nset.seed(703)\n```\n\n# 3 Load and format data\n\n## 3.1 RNA-seq data (mRNA, miRNA, lncRNA)\n\n``` r\n### mRNA ###\n# raw gene counts data (will filter and variance stabilize)\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\n```\n\n```         \n## Rows: 44371 Columns: 41\n## ── Column specification ────────────────────────────────────────────────────────\n## Delimiter: \",\"\n## chr  (1): gene_id\n## dbl (40): 1A1, 1A10, 1A12, 1A2, 1A8, 1A9, 1B1, 1B10, 1B2, 1B5, 1B9, 1C10, 1C...\n## \n## ℹ Use `spec()` to retrieve the full column specification for this data.\n## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n``` r\nApul_genes <- as.data.frame(Apul_genes)\n\n# format gene IDs as rownames (instead of a column)\nrownames(Apul_genes) <- Apul_genes$gene_id\nApul_genes <- Apul_genes%>%select(!gene_id)\n\n\n### miRNA ###\n# raw miRNA counts (will filter and variance stabilize)\nApul_miRNA <- read.table(file = \"../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt\", header = TRUE, sep = \"\\t\", check.names = FALSE)\n\n\n### lncRNA ###\n# raw lncRNA counts (will filter and variance stabilize)\nApul_lncRNA_full <- read.table(\"../output/08-Apul-lncRNA/counts.txt\", header = TRUE, sep = \"\\t\", skip = 1)\n\n# Remove info on genomic location, set lncRNA IDs as rownames\nrownames(Apul_lncRNA_full) <- Apul_lncRNA_full$Geneid\nApul_lncRNA <- Apul_lncRNA_full %>% select(-Geneid, -Chr, -Start, -End, -Strand, -Length)\n\n\n\n### load and format metadata ###\nmetadata <- read_csv(\"../../M-multi-species/data/rna_metadata.csv\")%>%select(AzentaSampleName, ColonyID, Timepoint) %>%\n  filter(grepl(\"ACR\", ColonyID))\n```\n\n```         \n## New names:\n## Rows: 117 Columns: 19\n## ── Column specification\n## ──────────────────────────────────────────────────────── Delimiter: \",\" chr\n## (13): SampleName, WellNumber, AzentaSampleName, ColonyID, Timepoint, Sam... dbl\n## (5): SampleNumber, Plate, TotalAmount-ng, Volume-uL, Conc-ng.uL lgl (1):\n## MethodUsedForSpectrophotometry\n## ℹ Use `spec()` to retrieve the full column specification for this data. ℹ\n## Specify the column types or set `show_col_types = FALSE` to quiet this message.\n## • `` -> `...19`\n```\n\n``` r\nmetadata$Sample <- paste0(metadata$ColonyID, \"-\", metadata$Timepoint)\nrownames(metadata) <- metadata$Sample\n```\n\n```         \n## Warning: Setting row names on a tibble is deprecated.\n```\n\n``` r\ncolonies <- unique(metadata$ColonyID)\n\n# Rename gene column names to include full sample info\ncolnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]\n\n# Rename miRNA column names to match formatting\ncolnames(Apul_miRNA) <- sub(\"_.*\", \"\", colnames(Apul_miRNA))\ncolnames(Apul_miRNA) <- metadata$Sample[match(colnames(Apul_miRNA), metadata$AzentaSampleName)]\n\n# rename lncRNA colin names to include full sample info\ncolnames(Apul_lncRNA) <- sub(\"...data.\", \"\", colnames(Apul_lncRNA))\ncolnames(Apul_lncRNA) <- sub(\".sorted.bam\", \"\", colnames(Apul_lncRNA))\ncolnames(Apul_lncRNA) <- metadata$Sample[match(colnames(Apul_lncRNA), metadata$AzentaSampleName)]\n```\n\n## 3.2 WGBS data\n\n``` r\n#pull processed files from Gannet \n# Note: Unfortunately we can't use the `cache` feature to make this process more time efficient, as it doesn't support long vectors\n\n# Define the base URL\nbase_url <- \"https://gannet.fish.washington.edu/seashell/bu-github/timeseries_molecular/D-Apul/output/15.5-Apul-bismark/\"\n\n# Read the HTML page\npage <- read_html(base_url)\n\n# Extract links to files\nfile_links <- page %>%\n  html_nodes(\"a\") %>%\n  html_attr(\"href\")\n\n# Filter for files ending in \"processed.txt\"\nprocessed_files <- file_links[grepl(\"processed\\\\.txt$\", file_links)]\n\n# Create full URLs\nfile_urls <- paste0(base_url, processed_files)\n\n# Function to read a file from URL\nread_processed_file <- function(url) {\n  read_table(url, col_types = cols(.default = \"c\"))  # Read as character to avoid parsing issues\n}\n\n# Import all processed files into a list\nprocessed_data <- lapply(file_urls, read_processed_file)\n\n# Name the list elements by file name\nnames(processed_data) <- processed_files\n\n# Print structure of imported data\nstr(processed_data)\n\n# add a header row that has \"CpG\" for the first column and \"sample\" for the second column, which will be populated by the file name \n\nprocessed_data <- Map(function(df, filename) {\n  colnames(df) <- c(\"CpG\", filename)  # Rename columns\n  return(df)\n}, processed_data, names(processed_data))  # Use stored file names\n\n#merge files together by \"CpG\"\nmerged_data <- purrr::reduce(processed_data, full_join, by = \"CpG\")\n\n# Print structure of final merged data\nstr(merged_data)\n```\n\nReplace any NA with 0.\n\n``` r\n# Convert all columns (except \"CpG\") to numeric and replace NAs with 0\nmerged_data <- merged_data %>%\n  mutate(across(-CpG, as.numeric)) %>%  # Convert all except CpG to numeric\n  mutate(across(-CpG, ~ replace_na(.x, 0)))  # Replace NA with 0 in numeric columns\n```\n\n## 3.3 Filter data sets\n\nOnly keep CpGs that have a non-zero value in all samples.\n\n``` r\nfiltered_wgbs <- merged_data %>% filter(if_all(-CpG, ~ .x > 0))\n\n# Ensure it's formatted as a data frame\nfiltered_wgbs <- as.data.frame(filtered_wgbs)\n# Only keep the sample information in the column name. \ncolnames(filtered_wgbs) <- gsub(\"^(.*?)_.*$\", \"\\\\1\", colnames(filtered_wgbs))\n# Set CpG IDs to rownames\nrownames(filtered_wgbs) <- filtered_wgbs$CpG\nfiltered_wgbs <- filtered_wgbs %>% select(-CpG)\n\nnrow(merged_data)\nnrow(filtered_wgbs)\n```\n\nWe had 12,093,025 CpGs before filtering and have only 507 after filtering. This makes sense because most CpGs were not methylated in all samples.\n\nSave filtered set to make code reruns/knitting quicker\n\n``` r\nwrite.csv(filtered_wgbs, \"../output/22.2-Apul-multiomic-machine-learning/filtered-WGBS-CpG-counts.csv\")\n```\n\nIf knitting/rerunning code, we can load in this filtered data here, instead of loading raw counts and reprocessing.\n\n``` r\nfiltered_wgbs <- read.csv(\"../output/22.2-Apul-multiomic-machine-learning/filtered-WGBS-CpG-counts.csv\", row.names = 1, check.names = FALSE)\n```\n\nOnly keep genes, miRNA, and lncRNA that are present in at least one sample\n\n``` r\n# genes\nApul_genes_red <- Apul_genes[rowSums(Apul_genes) != 0, ]\n# miRNA\nApul_miRNA_red <- Apul_miRNA[rowSums(Apul_miRNA) != 0, ]\n# lncRNA\nApul_lncRNA_red <- Apul_lncRNA[rowSums(Apul_lncRNA) != 0, ]\n\ncat(\"Retained \", nrow(Apul_genes_red), \" of \", nrow(Apul_genes), \"genes; \",\n       nrow(Apul_miRNA_red), \" of \", nrow(Apul_miRNA), \" miRNA; and \", \n       nrow(Apul_lncRNA_red), \" of \", nrow(Apul_lncRNA), \" lncRNA\")\n```\n\n```         \n## Retained  35869  of  44371 genes;  51  of  51  miRNA; and  20559  of  24181  lncRNA\n```\n\n*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Setting 3/40 = 0.08. This would retain genes that are only expressed in a single season in a couple of the colonies. Additionally, setting the minimum count so that the minimum number of samples must have a gene count above a certain threshold.\n\ngenes:\n\n``` r\nfilt <- filterfun(pOverA(0.08, 5))\n\n#create filter for the counts data\ngfilt <- genefilter(Apul_genes_red, filt)\n\n#identify genes to keep by count filter\ngkeep <- Apul_genes_red[gfilt,]\n\n#identify gene lists\ngn.keep <- rownames(gkeep)\n\n#gene count data filtered in PoverA, P percent of the samples have counts over A\nApul_genes_filt <- as.data.frame(Apul_genes_red[which(rownames(Apul_genes_red) %in% gn.keep),])\n\n#How many rows do we have before and after filtering?\ncat(\"Pre-filtering:\", nrow(Apul_genes_red), \"; Post-filtering:\", nrow(Apul_genes_filt))\n```\n\n```         \n## Pre-filtering: 35869 ; Post-filtering: 25730\n```\n\nmiRNA:\n\n``` r\nmifilt <- filterfun(pOverA(0.08, 5))\n\n#create filter for the counts data\nmifilt <- genefilter(Apul_miRNA_red, mifilt)\n\n#identify miRNA to keep by count filter\nmikeep <- Apul_miRNA_red[mifilt,]\n\n#identify miRNA to keep by count filter\nmikeep <- Apul_miRNA_red[mifilt,]\n\n#identify miRNA lists\nmi.keep <- rownames(mikeep)\n\n#miRNA count data filtered in PoverA, P percent of the samples have counts over A\nApul_miRNA_filt <- as.data.frame(Apul_miRNA_red[which(rownames(Apul_miRNA_red) %in% mi.keep),])\n\n#How many rows do we have before and after filtering?\ncat(\"Pre-filtering:\", nrow(Apul_miRNA_red), \"; Post-filtering:\", nrow(Apul_miRNA_filt))\n```\n\n```         \n## Pre-filtering: 51 ; Post-filtering: 47\n```\n\nOf the 51 miRNA, 47 were retained. Which were removed?\n\n``` r\nsetdiff(rownames(Apul_miRNA_red), rownames(Apul_miRNA_filt))\n```\n\n```         \n## [1] \"Cluster_5685\"  \"Cluster_11565\" \"Cluster_13647\" \"Cluster_14633\"\n```\n\nlncRNA:\n\n``` r\nlncfilt <- filterfun(pOverA(0.08, 5))\n\n#create filter for the counts data\nlncfilt <- genefilter(Apul_lncRNA_red, lncfilt)\n\n#identify lncRNA to keep by count filter\nlnckeep <- Apul_lncRNA_red[lncfilt,]\n\n#identify lncRNA to keep by count filter\nlnckeep <- Apul_lncRNA_red[lncfilt,]\n\n#identify lncRNA lists\nlnc.keep <- rownames(lnckeep)\n\n#lncRNA count data filtered in PoverA, P percent of the samples have counts over A\nApul_lncRNA_filt <- as.data.frame(Apul_lncRNA_red[which(rownames(Apul_lncRNA_red) %in% lnc.keep),])\n\n#How many rows do we have before and after filtering?\ncat(\"Pre-filtering:\", nrow(Apul_lncRNA_red), \"; Post-filtering:\", nrow(Apul_lncRNA_filt))\n```\n\n```         \n## Pre-filtering: 20559 ; Post-filtering: 16006\n```\n\n## 3.4 Transform data\n\nSet the order of genes, miRNA, lncRNA, wgbs, and metadata to all be the same.\n\n``` r\n# Ensure rownames of metadata are used as the desired column order\ndesired_order <- rownames(metadata)\n\n# Reorder data frame columns\nApul_genes_filt <- Apul_genes_filt[, desired_order]\nApul_miRNA_filt <- Apul_miRNA_filt[, desired_order]\nApul_lncRNA_filt <- Apul_lncRNA_filt[, desired_order]\nfiltered_wgbs <- filtered_wgbs[, desired_order]\n\n# Check they all match\nidentical(rownames(metadata), colnames(Apul_genes_filt))\n```\n\n```         \n## [1] TRUE\n```\n\n``` r\nidentical(rownames(metadata), colnames(Apul_miRNA_filt))\n```\n\n```         \n## [1] TRUE\n```\n\n``` r\nidentical(rownames(metadata), colnames(Apul_lncRNA_filt))\n```\n\n```         \n## [1] TRUE\n```\n\n``` r\nidentical(rownames(metadata), colnames(filtered_wgbs))\n```\n\n```         \n## [1] TRUE\n```\n\nUse a variance stabilized transformation for all four data sets. Variance stabilization essentially tries to make variance independent of the mean\n\n(Is this the most appropriate design to use?)\n\ngenes:\n\n``` r\ndds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt, \n                              colData = metadata, \n                              design = ~Timepoint+ColonyID)\n```\n\n```         \n## converting counts to integer mode\n\n## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in\n## design formula are characters, converting to factors\n\n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n```\n\n``` r\n# Variance Stabilizing Transformation\nvsd_genes <- assay(vst(dds_genes, blind = TRUE))\n```\n\nmiRNA:\n\n``` r\ndds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt, \n                              colData = metadata, \n                              design = ~Timepoint+ColonyID)\n```\n\n```         \n## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in\n## design formula are characters, converting to factors\n\n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n```\n\n``` r\n# Variance Stabilizing Transformation\nvsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=TRUE) # Must use varianceStabilizingTransformation() instead of vst() due to few input genes\n```\n\n```         \n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n```\n\n``` r\nvsd_miRNA <- assay(vsd_miRNA)\n```\n\nlncRNA:\n\n``` r\ndds_lncRNA <- DESeqDataSetFromMatrix(countData = Apul_lncRNA_filt, \n                              colData = metadata, \n                              design = ~Timepoint+ColonyID)\n```\n\n```         \n## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in\n## design formula are characters, converting to factors\n\n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n```\n\n``` r\n# Variance Stabilizing Transformation\nvsd_lncRNA <- assay(vst(dds_lncRNA, blind = TRUE))\n```\n\nMust round wgbs data to whole integers for normalization - need to return to this to decide if this is appropriate.\n\n``` r\n#round to integers \nfiltered_wgbs<-filtered_wgbs %>% mutate(across(where(is.numeric), round))\n\ndds_wgbs <- DESeqDataSetFromMatrix(countData = filtered_wgbs, \n                              colData = metadata, \n                              design = ~ Timepoint+ColonyID)\n```\n\n```         \n## converting counts to integer mode\n\n## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in\n## design formula are characters, converting to factors\n\n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n```\n\n``` r\n# Variance Stabilizing Transformation\nvsd_wgbs <- assay(varianceStabilizingTransformation(dds_wgbs, blind = TRUE))\n```\n\n```         \n##   Note: levels of factors in the design contain characters other than\n##   letters, numbers, '_' and '.'. It is recommended (but not required) to use\n##   only letters, numbers, and delimiters '_' or '.', as these are safe characters\n##   for column names in R. [This is a message, not a warning or an error]\n\n## -- note: fitType='parametric', but the dispersion trend was not well captured by the\n##    function: y = a/x + b, and a local regression fit was automatically substituted.\n##    specify fitType='local' or 'mean' to avoid this message next time.\n```\n\n## 3.5 Islolate gene sets\n\nRead in gene set tables\n\n``` r\n# genes from WGCNA modules significantly correlated with host biomass\nHost_AFDW <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Host_AFDW.mg.cm2_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n# genes from WGCNA modules significantly correlated with symbiont photosynthesis\nAm <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Am_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n# GO terms related to energy production/usage\nATP_production_GO <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/ATP_production_GO_terms_gene_counts.tab\", sep=\"\\t\", header=TRUE)\nenergy_GO <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/energy_usage_storage_GO_terms_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n```\n\nIsolate filtered counts by gene set\n\n``` r\nvsd_Host_AFDW <- vsd_genes[rownames(vsd_genes) %in% Host_AFDW$gene_id,]\nvsd_Am <- vsd_genes[rownames(vsd_genes) %in% Am$gene_id,]\nvsd_ATP_production_GO <- vsd_genes[rownames(vsd_genes) %in% ATP_production_GO$gene_id,]\nvsd_energy_GO <- vsd_genes[rownames(vsd_genes) %in% energy_GO$gene_id,]\n```\n\n# 5 Merge predictor features\n\n## 5.2 Merge raw datsets\n\nI also want to try using individiual miRNA/lncRNA/CpGs as predictors, instead of the reduced PCs. Let's also create a merged dataset that contains the variance stabilized counts for all miRNA, lncRNA, and CpGs.\n\n``` r\n# Triple check that all three data frames have sample names in the same order\nidentical(colnames(vsd_lncRNA), colnames(vsd_miRNA))\n```\n\n```         \n## [1] TRUE\n```\n\n``` r\nidentical(colnames(vsd_lncRNA), colnames(vsd_wgbs))\n```\n\n```         \n## [1] TRUE\n```\n\n``` r\n# Bind (stack dataframes vertically, so that they match by column/sample)\nfull_pred_counts <- rbind(vsd_lncRNA, vsd_miRNA, vsd_wgbs)\n\n# Transform so that samples are on rows and features are in columns\nfull_pred_counts <- t(full_pred_counts)\n\ndim(full_pred_counts)\n```\n\n```         \n## [1]    40 16560\n```\n\nOk, now we can run the model!\n\nThe below code uses both predictors (miRNA+lncRNA+CpGs) and responses (genes) that have been *not* been reduced using PCs.\n\n``` r\n# Transform the counts matrices so that samples are on the rows and gene IDs on the columns\nvsd_genes_t <- t(vsd_genes)\nvsd_Host_AFDW_t <- t(vsd_Host_AFDW)\nvsd_Am_t <- t(vsd_Am)\nvsd_ATP_production_GO_t <- t(vsd_ATP_production_GO)\nvsd_energy_GO_t <- t(vsd_energy_GO)\n\n# Ensure both are formatted as data frames\nfull_pred_counts <- as.data.frame(full_pred_counts)\nvsd_genes_t <- as.data.frame(vsd_genes_t)\nvsd_Host_AFDW_t <- as.data.frame(vsd_Host_AFDW_t)\nvsd_Am_t <- as.data.frame(vsd_Am_t)\nvsd_ATP_production_GO_t <- as.data.frame(vsd_ATP_production_GO_t)\nvsd_energy_GO_t <- as.data.frame(vsd_energy_GO_t)\n\n# Ensure sample matching between gene and epigenetic dfs\ncommon_samples <- intersect(rownames(vsd_genes_t), rownames(full_pred_counts))\n\nfull_pred_counts <- full_pred_counts[common_samples, ]\nvsd_genes_t <- vsd_genes_t[common_samples, ]\nvsd_Host_AFDW_t <- vsd_Host_AFDW_t[common_samples,]\nvsd_Am_t <- vsd_Am_t[common_samples,]\nvsd_ATP_production_GO_t <- vsd_ATP_production_GO_t[common_samples,]\nvsd_energy_GO_t <- vsd_energy_GO_t[common_samples,]\n```\n\n# 14 Host biomass (Host_AFDW)\n\n## 14.1 The model\n\nTrain elastic models to predict gene expression from miRNA/lncRNA/methylation.\n\n``` r\ntrain_models <- function(response_features, predictor_features) {\n  models <- list()\n  \n  for (feature in colnames(response_features)) {\n    y <- response_features[[feature]]  # Gene expression\n    X <- as.matrix(predictor_features)  # miRNA/lncRNA/methylation as predictors\n    \n    # Train elastic net model (alpha = 0.5 for mix of LASSO & Ridge)\n    model <- cv.glmnet(X, y, alpha = 0.5)\n    \n    models[[feature]] <- model\n  }\n  \n  return(models)\n}\n\n# Train models predicting gene expression from miRNA/lncRNA/methylation\nmodels_Host_AFDW <- train_models(vsd_Host_AFDW_t, full_pred_counts)\n```\n\nExtract feature importance.\n\n``` r\nget_feature_importance <- function(models) {\n  importance_list <- lapply(models, function(model) {\n    coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Convert to regular matrix & remove intercept\n    \n    # Convert to data frame\n    coefs_df <- data.frame(Feature = rownames(coefs), Importance = as.numeric(coefs))\n    \n    return(coefs_df)\n  })\n  \n  # Combine feature importance across all predicted genes\n  importance_df <- bind_rows(importance_list) %>%\n    group_by(Feature) %>%\n    summarize(MeanImportance = mean(abs(Importance)), .groups = \"drop\") %>%\n    arrange(desc(MeanImportance))\n  \n  return(importance_df)\n}\n\nfeature_importance_Host_AFDW <- get_feature_importance(models_Host_AFDW)\nhead(feature_importance_Host_AFDW, 20)  # Top predictive features\n```\n\n```         \n## # A tibble: 20 × 2\n##    Feature    MeanImportance\n##    <chr>               <dbl>\n##  1 PC20_miRNA         0.0906\n##  2 PC18_miRNA         0.0771\n##  3 PC17_miRNA         0.0762\n##  4 PC19_miRNA         0.0760\n##  5 PC16_miRNA         0.0753\n##  6 PC8_miRNA          0.0689\n##  7 PC3_miRNA          0.0674\n##  8 PC13_miRNA         0.0672\n##  9 PC11_miRNA         0.0669\n## 10 PC7_miRNA          0.0663\n## 11 PC9_miRNA          0.0581\n## 12 PC27_WGBS          0.0527\n## 13 PC26_WGBS          0.0516\n## 14 PC2_miRNA          0.0505\n## 15 PC14_miRNA         0.0471\n## 16 PC5_miRNA          0.0463\n## 17 PC12_miRNA         0.0440\n## 18 PC21_WGBS          0.0430\n## 19 PC13_WGBS          0.0430\n## 20 PC11_WGBS          0.0354\n```\n\nEvaluate performance.\n\n``` r\nevaluate_model_performance <- function(models, response_features, predictor_features) {\n  results <- data.frame(Feature = colnames(response_features), R2 = NA)\n\n  for (feature in colnames(response_features)) {\n    y <- response_features[[feature]]\n    X <- as.matrix(predictor_features)\n\n    model <- models[[feature]]\n    preds <- predict(model, X, s = \"lambda.min\")\n\n    R2 <- cor(y, preds)^2  # R-squared metric\n    results[results$Feature == feature, \"R2\"] <- R2\n  }\n\n  return(results)\n}\n\nperformance_results_Host_AFDW <- evaluate_model_performance(models_Host_AFDW, vsd_Host_AFDW_t, full_pred_counts)\nsummary(performance_results_Host_AFDW$R2)\n```\n\n```         \n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##  0.0000  0.9554  0.9919  0.9498  0.9996  0.9998      14\n```\n\n## 14.2 Results\n\nPlot results.\n\n``` r\n# Select top predictive features\ntop_features_Host_AFDW <- feature_importance_Host_AFDW %>% top_n(50, MeanImportance)\n\n# Plot\nggplot(top_features_Host_AFDW, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"miRNA/lncRNA/methylation as predictive features\",\n       x = \"Features\",\n       y = \"Mean Importance\")\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-90-1.png)<!-- -->\n\n``` r\nggplot(performance_results_Host_AFDW, aes(x = as.factor(Feature), y = R2)) +\n  geom_point(color = \"darkred\", size = 1) +\n  geom_hline(yintercept = mean(performance_results_Host_AFDW$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Genes\",\n       x = \"Gene\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n\n```         \n## Warning: Removed 14 rows containing missing values or values outside the scale range\n## (`geom_point()`).\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-91-1.png)<!-- -->\n\nWe can also look at which feature(s) contributed most to predicting genes of interest\n\n``` r\n# Will keep this unevaluated to reduce size of knitted document\nall_features_Host_AFDW <- performance_results_Host_AFDW %>% filter(R2 > 0.95) %>% pull(Feature)\n\nget_feature_importance_for_feature <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\nfor (feature in all_features_Host_AFDW) {\n  # Extract feature importance for the most predictable gene\n  best_feature_model <- models_Host_AFDW[[feature]]\n  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)\n  \n  # Plot top most important miRNA/lncRNA/methylation for predicting this gene\n  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n    geom_bar(stat = \"identity\", fill = \"steelblue\") +\n    coord_flip() +\n    theme_minimal() +\n    labs(title = paste(\"Top miRNA/lncRNA/methylation Predictors for\", feature),\n         x = \"Feature\",\n         y = \"Importance Score\")\n  \n  print(plot)\n}\n```\n\n``` r\n# Compute correlation between actual and predicted genes\npredicted_matrix <- sapply(models_Host_AFDW, function(m) predict(m, as.matrix(full_pred_counts), s = \"lambda.min\"))\n\n# Ensure matrices are the same size\npredicted_matrix <- predicted_matrix[, colnames(vsd_Host_AFDW_t), drop = FALSE]  # Align columns\n\n# remove 0 variance columns\npredicted_matrix <- predicted_matrix[, apply(predicted_matrix, 2, function(col) sd(col, na.rm = TRUE) > 0)]\n\n# Compute correlation matrix, handling missing values\ncor_matrix <- cor(predicted_matrix, as.matrix(vsd_Host_AFDW_t), use = \"complete.obs\")\n\n# Replace NA or Inf values with zero\ncor_matrix[is.na(cor_matrix) | is.infinite(cor_matrix)] <- 0  \n\n# Plot heatmap\npheatmap(cor_matrix, color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100),\n         main = \"Correlation Between Actual and Predicted Genes\",\n         cluster_rows = FALSE,\n         cluster_cols = FALSE,\n         fontsize = 10)\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-93-1.png)<!-- -->\n\n# 15 Symbiont photsynthesis (Am)\n\n## 15.1 The model\n\nTrain elastic models to predict gene expression from miRNA/lncRNA/methylation\n\n``` r\n# Train models predicting gene expression from miRNA/lncRNA/methylation\nmodels_Am <- train_models(vsd_Am_t, full_pred_counts)\n```\n\nExtract feature importance.\n\n``` r\nfeature_importance_Am <- get_feature_importance(models_Am)\nhead(feature_importance_Am, 20)  # Top predictive features\n```\n\nEvaluate performance.\n\n``` r\nperformance_results_Am <- evaluate_model_performance(models_Am, vsd_Am_t, full_pred_counts)\nsummary(performance_results_Am$R2)\n```\n\n## 15.2 Results\n\nPlot results.\n\n``` r\n# Select top predictive features\ntop_features_Am <- feature_importance_Am %>% top_n(50, MeanImportance)\n\n# Plot\nggplot(top_features_Am, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"miRNA/lncRNA/methylation as Predictive Features\",\n       x = \"Feature\",\n       y = \"Mean Importance\")\n```\n\n``` r\nggplot(performance_results_Am, aes(x = as.factor(Feature), y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results_Am$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n\nView predicted vs actual gene expression values to evaluate model.\n\n``` r\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_feature_Am <- performance_results_Am$Feature[which.max(performance_results_Am$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values_Am <- vsd_Am_t[[best_feature_Am]]\npredicted_values_Am <- predict(models_Am[[best_feature_Am]], as.matrix(full_pred_counts), s = \"lambda.min\")\n\n# Create data frame\nprediction_df_Am <- data.frame(\n  Actual = actual_values_Am,\n  Predicted = predicted_values_Am\n)\n\n# Scatter plot with regression line\nggplot(prediction_df_Am, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_feature_Am),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values_Am), y = max(predicted_values_Am), \n           label = paste(\"R² =\", round(max(performance_results_Am$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n## `geom_smooth()` using formula = 'y ~ x'\n```\n\nView top 20 genes associated with the PC with the highest R\\^2\n\n``` r\nprint(top_genes_Am%>%filter(Am_Feature==best_feature_Am))\n```\n\nPlot performance for all PCs\n\n``` r\n# Select all PCs with R^2 values above 0.75\nall_features_Am <- performance_results_Am %>% filter(R2 > 0.75) %>% pull(Feature)\n\nfor (feature in all_features_Am) {\n  \n  # Extract actual and predicted values for that PC\n  actual_values <- vsd_Am_t[[feature]]\n  predicted_values <- predict(models_Am[[feature]], as.matrix(full_pred_counts), s = \"lambda.min\")\n  \n  # Create data frame\n  prediction_df <- data.frame(\n    Actual = actual_values,\n    Predicted = predicted_values\n  )\n  \n  # Scatter plot with regression line\n  plot <- ggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n    geom_point(color = \"blue\", alpha = 0.7) +\n    geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n    theme_minimal() +\n    labs(title = paste(\"Predicted vs. Actual for\", feature),\n         x = \"Actual Gene Expression PC\",\n         y = \"Predicted Gene Expression PC\") +\n    annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n             label = paste(\"R² =\", round(max(performance_results_Am[performance_results_Am$Feature==feature,2], na.rm=TRUE), 3)), \n             hjust = 0, color = \"black\", size = 5)\n  \n  print(plot)\n}\n```\n\nWe can also look at which miRNA(s) contributed most to predicting gene PCs of interest\n\n``` r\nget_feature_importance_for_feature <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\nfor (feature in all_features_Am) {\n  # Extract feature importance for the most predictable PC\n  best_feature_model <- models_Am[[feature]]\n  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)\n  \n  # Plot top most important miRNA/lncRNA/methylation for predicting this PC\n  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n    geom_bar(stat = \"identity\", fill = \"steelblue\") +\n    coord_flip() +\n    theme_minimal() +\n    labs(title = paste(\"Top miRNA/lncRNA/methylation Predictors for\", feature),\n         x = \"Feature\",\n         y = \"Importance Score\")\n  \n  print(plot)\n}\n```\n\n# 16 ATP production (GO terms)\n\n## 16.1 The model\n\nTrain elastic models to predict gene expression PCs from miRNA/lncRNA/methylation\n\n``` r\n# Train models predicting gene expression PCs from miRNA/lncRNA/methylation\nmodels_ATP_prod_GO <- train_models(vsd_ATP_production_GO_t, full_pred_counts)\n```\n\nExtract feature importance.\n\n``` r\nfeature_importance_ATP_prod_GO <- get_feature_importance(models_ATP_prod_GO)\nhead(feature_importance_ATP_prod_GO, 20)  # Top predictive miRNA\n```\n\n```         \n## # A tibble: 20 × 2\n##    Feature                MeanImportance\n##    <chr>                           <dbl>\n##  1 lncRNA_16172                  0.0151 \n##  2 lncRNA_19034                  0.0137 \n##  3 lncRNA_3645                   0.0125 \n##  4 lncRNA_20796                  0.0110 \n##  5 lncRNA_4454                   0.00999\n##  6 lncRNA_8058                   0.00920\n##  7 lncRNA_18277                  0.00918\n##  8 CpG_ptg000024l_4334252        0.00893\n##  9 lncRNA_9242                   0.00818\n## 10 lncRNA_263                    0.00782\n## 11 lncRNA_3622                   0.00781\n## 12 lncRNA_9252                   0.00773\n## 13 CpG_ptg000031l_5273398        0.00716\n## 14 lncRNA_19773                  0.00687\n## 15 CpG_ptg000022l_2983280        0.00683\n## 16 lncRNA_11719                  0.00667\n## 17 CpG_ptg000024l_213653         0.00665\n## 18 lncRNA_23085                  0.00664\n## 19 lncRNA_18158                  0.00655\n## 20 lncRNA_7887                   0.00652\n```\n\nEvaluate performance.\n\n``` r\nperformance_results_ATP_prod_GO <- evaluate_model_performance(models_ATP_prod_GO, vsd_ATP_production_GO_t, full_pred_counts)\nsummary(performance_results_ATP_prod_GO$R2)\n```\n\n```         \n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##  0.0000  0.9644  0.9957  0.9366  0.9996  0.9997\n```\n\n## 16.2 Results\n\nPlot results.\n\n``` r\n# Select top predictive features\ntop_features_ATP_prod_GO <- feature_importance_ATP_prod_GO %>% top_n(50, MeanImportance)\n\n# Plot\nggplot(top_features_ATP_prod_GO, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"miRNA/lncRNA/methylation as Predictive Features\",\n       x = \"Feature\",\n       y = \"Mean Importance\")\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-106-1.png)<!-- -->\n\n``` r\nggplot(performance_results_ATP_prod_GO, aes(x = as.factor(Feature), y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results_ATP_prod_GO$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-107-1.png)<!-- -->\n\nView predicted vs actual gene expression values to evaluate model.\n\n``` r\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_feature_ATP_prod_GO <- performance_results_ATP_prod_GO$Feature[which.max(performance_results_ATP_prod_GO$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values_ATP_prod_GO <- vsd_ATP_production_GO_t[[best_feature_ATP_prod_GO]]\npredicted_values_ATP_prod_GO <- predict(models_ATP_prod_GO[[best_feature_ATP_prod_GO]], as.matrix(full_pred_counts), s = \"lambda.min\")\n\n# Create data frame\nprediction_df_ATP_prod_GO <- data.frame(\n  Actual = actual_values_ATP_prod_GO,\n  Predicted = predicted_values_ATP_prod_GO\n)\n\n# Scatter plot with regression line\nggplot(prediction_df_ATP_prod_GO, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_feature_ATP_prod_GO),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values_ATP_prod_GO), y = max(predicted_values_ATP_prod_GO), \n           label = paste(\"R² =\", round(max(performance_results_ATP_prod_GO$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n```\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-108-1.png)<!-- -->\n\n``` r\n## `geom_smooth()` using formula = 'y ~ x'\n```\n\nPlot performance for all PCs\n\n``` r\n# Select all PCs with R^2 values above line in plot\nall_features_ATP_prod_GO <- performance_results_ATP_prod_GO %>% filter(R2 > 0.75) %>% pull(Feature)\n\nfor (feature in all_features_ATP_prod_GO) {\n  \n  # Extract actual and predicted values for that PC\n  actual_values <- vsd_ATP_production_GO_t[[feature]]\n  predicted_values <- predict(models_ATP_prod_GO[[feature]], as.matrix(full_pred_counts), s = \"lambda.min\")\n  \n  # Create data frame\n  prediction_df <- data.frame(\n    Actual = actual_values,\n    Predicted = predicted_values\n  )\n  \n  # Scatter plot with regression line\n  plot <- ggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n    geom_point(color = \"blue\", alpha = 0.7) +\n    geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n    theme_minimal() +\n    labs(title = paste(\"Predicted vs. Actual for\", feature),\n         x = \"Actual Gene Expression PC\",\n         y = \"Predicted Gene Expression PC\") +\n    annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n             label = paste(\"R² =\", round(max(performance_results_ATP_prod_GO[performance_results_ATP_prod_GO$Feature==feature,2], na.rm=TRUE), 3)), \n             hjust = 0, color = \"black\", size = 5)\n  \n  print(plot)\n}\n```\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-1.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-2.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-3.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-4.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-5.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-6.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-7.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-8.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-9.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-10.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-11.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-12.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-13.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-14.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-15.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-16.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-17.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-18.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-19.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-20.png)<!-- -->\n\n```         \n## `geom_smooth()` using formula = 'y ~ x'\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-109-21.png)<!-- -->\n\nWe can also look at which miRNA(s) contributed most to predicting gene PCs of interest\n\n``` r\nget_feature_importance_for_feature <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\nfor (feature in all_features_ATP_prod_GO) {\n  # Extract feature importance for the most predictable PC\n  best_feature_model <- models_ATP_prod_GO[[feature]]\n  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)\n  \n  # Plot top most important miRNA/lncRNA/methylation for predicting this PC\n  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n    geom_bar(stat = \"identity\", fill = \"steelblue\") +\n    coord_flip() +\n    theme_minimal() +\n    labs(title = paste(\"Top miRNA/lncRNA/methylation Predictors for\", feature),\n         x = \"Feature\",\n         y = \"Importance Score\")\n  \n  print(plot)\n}\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-1.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-2.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-3.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-4.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-5.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-6.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-7.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-8.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-9.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-10.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-11.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-12.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-13.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-14.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-15.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-16.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-17.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-18.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-19.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-20.png)<!-- -->![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-110-21.png)<!-- -->\n\n``` r\n# Compute correlation between actual and predicted gene expression PCs\npredicted_matrix <- sapply(models_ATP_prod_GO, function(m) predict(m, as.matrix(full_pred_counts), s = \"lambda.min\"))\n\n# Ensure matrices are the same size\npredicted_matrix <- predicted_matrix[, colnames(vsd_ATP_production_GO_t), drop = FALSE]  # Align columns\n\n# remove 0 variance columns\npredicted_matrix <- predicted_matrix[, apply(predicted_matrix, 2, function(col) sd(col, na.rm = TRUE) > 0)]\n\n# Compute correlation matrix, handling missing values\ncor_matrix <- cor(predicted_matrix, as.matrix(vsd_ATP_production_GO_t), use = \"complete.obs\")\n\n# Replace NA or Inf values with zero\ncor_matrix[is.na(cor_matrix) | is.infinite(cor_matrix)] <- 0  \n\n# Plot heatmap\npheatmap(cor_matrix, color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(100),\n         main = \"Correlation Between Actual and Predicted Gene Expression PCs\",\n         cluster_rows = FALSE,\n         cluster_cols = FALSE,\n         fontsize = 10)\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-111-1.png)<!-- -->\n\n# 17 Energy Usage/Storage (GO terms)\n\n## 17.1 The model\n\nTrain elastic models to predict gene expression PCs from miRNA/lncRNA/methylation\n\n``` r\n# Train models predicting gene expression PCs from miRNA/lncRNA/methylation\nmodels_energy_GO <- train_models(vsd_energy_GO_t, full_pred_counts)\n```\n\nExtract feature importance.\n\n``` r\nfeature_importance_energy_GO <- get_feature_importance(models_energy_GO)\nhead(feature_importance_energy_GO, 20)  # Top predictive miRNA\n```\n\n```         \n## # A tibble: 20 × 2\n##    Feature                 MeanImportance\n##    <chr>                            <dbl>\n##  1 lncRNA_19034                   0.00555\n##  2 lncRNA_4454                    0.00373\n##  3 lncRNA_2998                    0.00302\n##  4 lncRNA_12064                   0.00248\n##  5 CpG_ptg000025l_18378678        0.00244\n##  6 lncRNA_12212                   0.00237\n##  7 lncRNA_8086                    0.00221\n##  8 lncRNA_20796                   0.00216\n##  9 lncRNA_13960                   0.00215\n## 10 lncRNA_263                     0.00214\n## 11 lncRNA_21989                   0.00210\n## 12 lncRNA_15222                   0.00210\n## 13 lncRNA_7887                    0.00208\n## 14 CpG_ptg000024l_4334565         0.00206\n## 15 lncRNA_16584                   0.00205\n## 16 lncRNA_6545                    0.00203\n## 17 lncRNA_1395                    0.00199\n## 18 lncRNA_22939                   0.00199\n## 19 lncRNA_16417                   0.00198\n## 20 CpG_ptg000021l_8434453         0.00194\n```\n\nEvaluate performance.\n\n``` r\nperformance_results_energy_GO <- evaluate_model_performance(models_energy_GO, vsd_energy_GO_t, full_pred_counts)\nsummary(performance_results_energy_GO$R2)\n```\n\n```         \n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n##  0.3597  0.9565  0.9950  0.9574  0.9996  0.9998       3\n```\n\n## 17.2 Results\n\nPlot results.\n\n``` r\n# Select top predictive features\ntop_features_energy_GO <- feature_importance_energy_GO %>% top_n(50, MeanImportance)\n\n# Plot\nggplot(top_features_energy_GO, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"miRNA/lncRNA/methylation as Predictive Features\",\n       x = \"Feature\",\n       y = \"Mean Importance\")\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-115-1.png)<!-- -->\n\n``` r\nggplot(performance_results_energy_GO, aes(x = as.factor(Feature), y = R2)) +\n  geom_point(color = \"darkred\", size = 1.5) +\n  geom_hline(yintercept = mean(performance_results_energy_GO$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n\n```         \n## Warning: Removed 3 rows containing missing values or values outside the scale range\n## (`geom_point()`).\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-116-1.png)<!-- -->\n\nWe can also look at which miRNA(s) contributed most to predicting gene PCs of interest\n\n``` r\n# Will keep this unevaluated to reduce size of knitted document\nget_feature_importance_for_feature <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\nall_features_energy_GO <- performance_results_energy_GO %>% filter(R2 > 0.75) %>% pull(Feature)\n\nfor (feature in all_features_energy_GO) {\n  # Extract feature importance for the most predictable PC\n  best_feature_model <- models_energy_GO[[feature]]\n  best_feature_importance <- get_feature_importance_for_feature(best_feature_model)\n  \n  # Plot top most important miRNA/lncRNA/methylation for predicting this PC\n  plot <- ggplot(best_feature_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n    geom_bar(stat = \"identity\", fill = \"steelblue\") +\n    coord_flip() +\n    theme_minimal() +\n    labs(title = paste(\"Top miRNA/lncRNA/methylation Predictors for\", feature),\n         x = \"Feature\",\n         y = \"Importance Score\")\n  \n  print(plot)\n}\n```\n\n# 18 Compare\n\nVisualize the relative importance of miRNA/lncRNA/methylation in predicting expression for these different gene sets:\n\n``` r\n# Perform min-max normalization on the mean importance of miRNA/lncRNA/methylation for each group\n# This will place all along a 0-1 range for comparison purposes\nnormalize <- function(x) {\n  (x - min(x)) / (max(x) - min(x))\n}\n\n# Normalize\ntop_features_Host_AFDW$MeanImportance_norm <- normalize(top_features_Host_AFDW$MeanImportance)\n#top_features_Am$MeanImportance_norm <- normalize(top_features_Am$MeanImportance)\ntop_features_ATP_prod_GO$MeanImportance_norm <- normalize(top_features_ATP_prod_GO$MeanImportance)\ntop_features_energy_GO$MeanImportance_norm <- normalize(top_features_energy_GO$MeanImportance)\n\n# Add group labels\ntop_features_Host_AFDW <- top_features_Host_AFDW %>% mutate(group = \"Host_AFDW\")\n#top_features_Am <- top_features_Am %>% mutate(group = \"Am\")\ntop_features_ATP_prod_GO <- top_features_ATP_prod_GO %>% mutate(group = \"ATP_prod_GO\")\ntop_features_energy_GO <- top_features_energy_GO %>% mutate(group = \"energy_GO\")\n\n# Set rows in same order\n#top_features_Am <- top_features_Am[rownames(top_features_Host_AFDW),]\ntop_features_ATP_prod_GO <- top_features_ATP_prod_GO[rownames(top_features_Host_AFDW),]\ntop_features_energy_GO <- top_features_energy_GO[rownames(top_features_Host_AFDW),]\n\n# Combine\nall_gene_sets <- bind_rows(top_features_Host_AFDW, \n                           #top_features_Am, \n                           top_features_ATP_prod_GO, top_features_energy_GO)\n# Remove raw mean importance\nall_gene_sets <- all_gene_sets %>% select(!MeanImportance)\n\n# Wide format: rows = miRNAs, columns = groups\nheatmap_df <- all_gene_sets %>%\n  pivot_wider(names_from = group, values_from = MeanImportance_norm)\n\nheatmap_df <- as.data.frame(heatmap_df)\n\n# Melt into long format for ggplot\nheatmap_long <- melt(heatmap_df, id.vars = \"Feature\")\n\nggplot(heatmap_long, aes(x = variable, y = Feature, fill = value)) +\n  geom_tile(color = \"white\") +\n  scale_fill_gradient(low = \"white\", high = \"red\") +\n  theme_minimal() +\n  labs(x = \"Group\", y = \"Feature\", fill = \"Importance\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-118-1.png)<!-- -->\n\nCluster by miRNA/lncRNA/methylation importance\n\n``` r\n# Make Feature column the rownames and convert to matrix\nrownames(heatmap_df) <- heatmap_df$Feature\nheatmap_matrix <- as.matrix(heatmap_df[, -1])  # Removes the 'Feature' column\n\n# Replace NAs with 0\nheatmap_matrix[is.na(heatmap_matrix)] <- 0\n\npheatmap(\n  heatmap_matrix, \n  cluster_rows = TRUE,  # Clustering miRNAs (rows) by similarity in importance\n  cluster_cols = TRUE,  # Clustering groups (columns)\n  scale = \"none\",  # No scaling (since data is already normalized)\n  show_rownames = TRUE,  # Show miRNA/lncRNA/methylation names\n  show_colnames = TRUE,  # Show group names\n  color = colorRampPalette(c(\"white\", \"red\"))(100),  # Red gradient for importance\n  main = \"miRNAs Importance Across Groups\"  # Title of the heatmap\n)\n```\n\n![](./images/22.2-Apul-multiomic-machine-learning_files/figure-gfm/unnamed-chunk-119-1.png)<!-- -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}