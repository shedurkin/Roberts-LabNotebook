{
  "hash": "8683e61f9f1bc70c2828c525916e8581",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul phenotype and gene/miRNA machine learning -- Part 1\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-03-31\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\n[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning.Rmd)\\\n[Rendered code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning.md)\n\nI'd like to see whether phenotype can predict gene and/or miRNA expression, will be testing this using the ML approach Ariana has been trialing (see her mRNA-WGBS ML post here: <https://ahuffmyer.github.io/ASH_Putnam_Lab_Notebook/E5-timeseries-molecular-mRNA-WGBS-machine-learning-analysis-Part-1/>)\n\n# Results\n\nI filtered, variance stabilized, and combined the raw gene counts and miRNA counts. Then, due to the high number, I reduced this combined expression data to PCs of similar expression. For phenotype, I used host biomass, host protein, and respiration, all of which are indicators of host energy storage and expenditure. I ran the ML model using phenotypes as the predictor and expression PCs as the response.\n\nProtein was most predictive of expression, with respiration also highly predictive. Interestingly, biomass did not contribute much!\n\n![](images/Top-20-Predictive-Phys-Features.png)\n\nNone of the gene PCs were well-predicted by phenotype, with the highest R^2^ value sitting at 0.177 (\\~18% of variance in the PCs explained by phenotype).\n\n![](images/Model-Performance-Across-Gene-Expression-PCs.png)Also, most of the expression PCs (21/31) had NA R^2^ values, which I believe is related to low variance in the phenotype metrics, particularly the protein phenotype\n\n```         \n> apply(merged_pcs, 2, var)\n```\n\n```         \n      PC1       PC2       PC3       PC4       PC5       PC6       PC7       PC8       PC9      PC10      PC11      PC12      PC13      PC14      PC15      PC16      PC17 \n5801.1357 2808.7631 2370.6702 1990.1140 1760.0861 1627.7522 1317.6404 1274.2452 1078.4045 1034.5725  976.4311  937.5277  891.5255  796.3490  779.2450  699.0609  676.0976 \n     PC18      PC19      PC20      PC21      PC22      PC23      PC24      PC25      PC26      PC27      PC28      PC29      PC30      PC31 \n 650.9711  620.9733  606.8573  591.2129  575.7182  550.6815  528.1735  519.2895  506.3591  474.2105  467.2894  454.2832  436.9429  423.9563 \n```\n\n```         \n> apply(phys_selection, 2, var)\n```\n\n```         \nHost_AFDW.mg.cm2   prot_mg.mgafdw               Rd \n      0.33627626       0.01063323       0.03545622 \n```\n\nWe can look at model performance for specific expression PCs. For example, here's PC9, which is the best-predicted PC (highest R^2^ value)\n\n![](images/Predicted-v-Actual-PC9.png)We can also look at the top miRNA/genes associated with it. This was interesting because there is an miRNA that pops out (Cluster_4034)!\n\n```         \n## # A tibble: 20 × 3\n## # Groups:   Merged_PC [1]\n##    gene_miRNA   Merged_PC Loading\n##    <chr>        <chr>       <dbl>\n##  1 FUN_023262   PC9       -0.0227\n##  2 FUN_016918   PC9        0.0198\n##  3 FUN_007014   PC9       -0.0194\n##  4 FUN_031632   PC9        0.0192\n##  5 FUN_035523   PC9        0.0188\n##  6 FUN_041996   PC9        0.0188\n##  7 FUN_006731   PC9       -0.0186\n##  8 FUN_022897   PC9       -0.0185\n##  9 FUN_043835   PC9        0.0184\n## 10 FUN_004465   PC9        0.0183\n## 11 FUN_014188   PC9       -0.0183\n## 12 FUN_034114   PC9       -0.0181\n## 13 FUN_024741   PC9       -0.0181\n## 14 FUN_006446   PC9       -0.0179\n## 15 FUN_018629   PC9       -0.0178\n## 16 FUN_013857   PC9       -0.0178\n## 17 Cluster_4034 PC9        0.0176\n## 18 FUN_039308   PC9       -0.0175\n## 19 FUN_012117   PC9        0.0175\n## 20 FUN_000459   PC9       -0.0174\n```\n\n### Code copied below in case of file path changes:\n\nInputs:\n\n-   RNA counts matrix (raw): `../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv`\n\n-   sRNA/miRNA counts matrix (raw): `../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt`\n\n-   sample metadata: `../../M-multi-species/data/rna_metadata.csv`\n\n-   physiological data: https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\n\nNote that I'll start by using phenotype (e.g. biomass, respiration) as the predictor, which is suitable for understanding *how external factors drive gene expression changes.*\n\nIf, instead, we wanted to build some sort of predictive model, where *gene expression could be used to predict phenotype*, we could switch so that gene counts are used as the predictors.\n\n# Load libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(DESeq2)\nlibrary(igraph)\nlibrary(psych)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(WGCNA)\nlibrary(edgeR)\nlibrary(reshape2)\nlibrary(ggcorrplot)\nlibrary(corrplot)\nlibrary(rvest)\nlibrary(purrr)\nlibrary(pheatmap)\nlibrary(glmnet)\nlibrary(caret)\nlibrary(factoextra)\nlibrary(vegan)\nlibrary(ggfortify)\n```\n:::\n\n\n# Load and prep data\n\nLoad in count matrices for RNAseq.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# raw gene counts data (will filter and variance stabilize)\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\nApul_genes <- as.data.frame(Apul_genes)\n\n# format gene IDs as rownames (instead of a column)\nrownames(Apul_genes) <- Apul_genes$gene_id\nApul_genes <- Apul_genes%>%select(!gene_id)\n\n\n# load and format metadata\nmetadata <- read_csv(\"../../M-multi-species/data/rna_metadata.csv\")%>%select(AzentaSampleName, ColonyID, Timepoint) %>%\n  filter(grepl(\"ACR\", ColonyID))\nmetadata$Sample <- paste(metadata$AzentaSampleName, metadata$ColonyID, metadata$Timepoint, sep = \"_\")\n\ncolonies <- unique(metadata$ColonyID)\n\n# Load physiological data\nphys<-read_csv(\"https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\")%>%filter(colony_id_corr %in% colonies)%>%\n  select(colony_id_corr, species, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, AQY, Rd, Ik, Ic, calc.umol.cm2.hr, cells.mgAFDW, prot_mg.mgafdw, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, cre.umol.mgafdw)\n# format timepoint\nphys$timepoint <- gsub(\"timepoint\", \"TP\", phys$timepoint)\n#add column with full sample info\nphys <- merge(phys, metadata, by.x = c(\"colony_id_corr\", \"timepoint\"), by.y = c(\"ColonyID\", \"Timepoint\")) %>%\n  select(-AzentaSampleName)\n  \n\n#add site information into metadata \nmetadata$Site<-phys$site[match(metadata$ColonyID, phys$colony_id_corr)]\n\n\n# Rename gene column names to include full sample info (as in miRNA table)\ncolnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]\n\n# raw miRNA counts (will filter and variance stabilize)\nApul_miRNA <- read.table(file = \"../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt\", header = TRUE, sep = \"\\t\", check.names = FALSE)\n```\n:::\n\n\n## Counts filtering\n\nEnsure there are no genes or miRNAs with 0 counts across all samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(Apul_genes)\n\nApul_genes_filt<-Apul_genes %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_genes_filt)\n\n# miRNAs\nnrow(Apul_miRNA)\n\nApul_miRNA_filt<-Apul_miRNA %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_miRNA_filt)\n```\n:::\n\n\nRemoving genes with only 0 counts reduced number from 44371 to 35869. Retained all 51 miRNAs.\n\nWill not be performing pOverA filtering for now, since LM should presumabily incorporate sample representation\n\n## Physiology filtering\n\nRun PCA on physiology data to see if there are phys outliers\n\nExport data for PERMANOVA test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest<-as.data.frame(phys)\ntest<-test[complete.cases(test), ]\n```\n:::\n\n\nBuild PERMANOVA model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_test <-prcomp(test%>%select(where(is.numeric)), scale=TRUE, center=TRUE)\nfviz_eig(scaled_test)\n\n# scale data\nvegan <- scale(test%>%select(where(is.numeric)))\n\n# PerMANOVA \npermanova<-adonis2(vegan ~ timepoint*site, data = test, method='eu')\npermanova\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npca1<-ggplot2::autoplot(scaled_test, data=test, frame.colour=\"timepoint\", loadings=FALSE,  colour=\"timepoint\", shape=\"site\", loadings.label.colour=\"black\", loadings.colour=\"black\", loadings.label=FALSE, frame=FALSE, loadings.label.size=5, loadings.label.vjust=-1, size=5) + \n  geom_text(aes(x = PC1, y = PC2, label = paste(colony_id_corr, timepoint)), vjust = -0.5)+\n  theme_classic()+\n   theme(legend.text = element_text(size=18), \n         legend.position=\"right\",\n        plot.background = element_blank(),\n        legend.title = element_text(size=18, face=\"bold\"), \n        axis.text = element_text(size=18), \n        axis.title = element_text(size=18,  face=\"bold\"));pca1\n```\n:::\n\n\nRemove ACR-173, timepoint 3 sample from analysis. This is Azenta sample 1B2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nApul_miRNA_filt <- Apul_miRNA_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B2_ACR-173_TP3\")\n```\n:::\n\n\nWe also do not have phys data for colony 1B9 ACR-265 at TP4, so I'll remove that here as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nApul_miRNA_filt <- Apul_miRNA_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B9_ACR-265_TP4\")\n```\n:::\n\n\n## Assign metadata and arrange order of columns\n\nOrder metadata the same as the column order in the gene matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist<-colnames(Apul_genes_filt)\nlist<-as.factor(list)\n\nmetadata$Sample<-as.factor(metadata$Sample)\n\n# Re-order the levels\nmetadata$Sample <- factor(as.character(metadata$Sample), levels=list)\n# Re-order the data.frame\nmetadata_ordered <- metadata[order(metadata$Sample),]\nmetadata_ordered$Sample\n\n# Make sure the miRNA colnames are also in the same order as the gene colnames\nApul_miRNA_filt <- Apul_miRNA_filt[, colnames(Apul_genes_filt)]\n```\n:::\n\n\nMetadata and gene count matrix are now ordered the same.\n\n## Conduct variance stabilized transformation\n\nVST should be performed on our two input datasets (gene counts and miRNA counts) separately\n\n### Genes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_genes <- estimateSizeFactors(dds_genes) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_genes)) #View size factors\n\nall(sizeFactors(SF.dds_genes)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes <- vst(dds_genes, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size\nvsd_genes <- assay(vsd_genes)\nhead(vsd_genes, 3) #view transformed gene count data for the first three genes in the dataset.  \n```\n:::\n\n\n### miRNA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_miRNA <- estimateSizeFactors(dds_miRNA) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_miRNA)) #View size factors\n\nall(sizeFactors(SF.dds_miRNA)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size. Using varianceStabilizingTransformation() instead of vst() because few input genes\nvsd_miRNA <- assay(vsd_miRNA)\nhead(vsd_miRNA, 3) #view transformed gene count data for the first three genes in the dataset.\n```\n:::\n\n\n## Combine counts data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract variance stabilized counts as dataframes\n# want samples in rows, genes/miRNAs in columns\nvsd_genes <- as.data.frame(t(vsd_genes))\nvsd_miRNA <- as.data.frame(t(vsd_miRNA))\n\n# Double check the row names (sample names) are in same order\nrownames(vsd_genes) == rownames(vsd_miRNA)\n\n# Combine vst gene counts and vst miRNA counts by rows (sample names)\nvsd_merged <- cbind(vsd_genes, vsd_miRNA)\n```\n:::\n\n\n# Feature selection\n\n## Genes + miRNA\n\nWe have a large number of genes, so we'll reduce dimensionality using PCA. Note that, since we only have a few phenotypes of interest, we don't need to reduce this dataset\n\nFirst need to remove any genes/miRNA that are invariant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_merged_filt <- vsd_merged[, apply(vsd_merged, 2, var) > 0]\n\nncol(vsd_merged)\nncol(vsd_merged_filt)\n\ncolnames(vsd_merged[, apply(vsd_merged, 2, var) == 0])\n```\n:::\n\n\nRemoved 74 invariant genes. I was worried we lost miRNA, but it looks like everything removed was a gene (prefix \"FUN\")!\n\nReduce dimensionality (genes+miRNA)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA on gene+miRNA expression matrix\npca_merged <- prcomp(vsd_merged_filt, scale. = TRUE)\n\n# Select top PCs that explain most variance (e.g., top 50 PCs)\nexplained_var <- summary(pca_merged)$importance[2, ]  # Cumulative variance explained\nnum_pcs <- min(which(cumsum(explained_var) > 0.95))  # Keep PCs that explain 95% variance\n\nmerged_pcs <- as.data.frame(pca_merged$x[, 1:num_pcs])  # Extract selected PCs\n\ndim(merged_pcs)\n```\n:::\n\n\nWe have 27 gene/miRNA expression PCs\n\n## Genes only\n\nTo investigate gene expression separately from miRNA expression, reduce dimensionality of genes alone.\n\nRemove any genes that are invariant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes_filt <- vsd_genes[, apply(vsd_genes, 2, var) > 0]\n\nncol(vsd_genes)\nncol(vsd_genes_filt)\n```\n:::\n\n\nRemoved 74 invariant genes.\n\nReduce dimensionality\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA on gene expression matrix\npca_genes <- prcomp(vsd_genes_filt, scale. = TRUE)\n\n# Select top PCs that explain most variance (e.g., top 50 PCs)\nexplained_var_genes <- summary(pca_genes)$importance[2, ]  # Cumulative variance explained\nnum_pcs_genes <- min(which(cumsum(explained_var_genes) > 0.95))  # Keep PCs that explain 95% variance\n\ngenes_pcs <- as.data.frame(pca_genes$x[, 1:num_pcs_genes])  # Extract selected PCs\n\ndim(genes_pcs)\n```\n:::\n\n\n## Physiological metrics\n\nSelect physiological metrics of interest. For now we'll focus on biomass (\"Host_AFDW.mg.cm2\"), protein (\"prot_mg.mgafdw\"), and respiration (\"Rd\"). These are all metrics of host energy storage and expenditure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign sample IDs to row names\nrownames(phys) <- phys$Sample\n\n# Select metrics\nphys_selection <- phys %>% select(Host_AFDW.mg.cm2, prot_mg.mgafdw, Rd)\n\n# Make sure the phys rownames are in the same order as the gene/miRNA rownames\nphys_selection <- phys_selection[rownames(merged_pcs),]\n```\n:::\n\n\n# Phenotype to predict gene/miRNA expression\n\n## The model\n\nTrain elastic models to predict gene expression PCs from phys data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_models <- function(response_pcs, predictor_pcs) {\n  models <- list()\n  \n  for (pc in colnames(response_pcs)) {\n    y <- response_pcs[[pc]]  # Gene expression PC\n    X <- as.matrix(predictor_pcs)  # Phys as predictors\n    \n    # Train elastic net model (alpha = 0.5 for mix of LASSO & Ridge)\n    model <- cv.glmnet(X, y, alpha = 0.5)\n    \n    models[[pc]] <- model\n  }\n  \n  return(models)\n}\n\n# Train models predicting gene expression PCs from phys data\nmodels <- train_models(merged_pcs, phys_selection)\n```\n:::\n\n\nExtract feature importance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_feature_importance <- function(models) {\n  importance_list <- lapply(models, function(model) {\n    coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Convert to regular matrix & remove intercept\n    \n    # Convert to data frame\n    coefs_df <- data.frame(Feature = rownames(coefs), Importance = as.numeric(coefs))\n    \n    return(coefs_df)\n  })\n  \n  # Combine feature importance across all predicted gene PCs\n  importance_df <- bind_rows(importance_list) %>%\n    group_by(Feature) %>%\n    summarize(MeanImportance = mean(abs(Importance)), .groups = \"drop\") %>%\n    arrange(desc(MeanImportance))\n  \n  return(importance_df)\n}\n\nfeature_importance <- get_feature_importance(models)\nhead(feature_importance, 20)  # Top predictive phys features\n```\n:::\n\n\nEvaluate performance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevaluate_model_performance <- function(models, response_pcs, predictor_pcs) {\n  results <- data.frame(PC = colnames(response_pcs), R2 = NA)\n  \n  for (pc in colnames(response_pcs)) {\n    y <- response_pcs[[pc]]\n    X <- as.matrix(predictor_pcs)\n    \n    model <- models[[pc]]\n    preds <- predict(model, X, s = \"lambda.min\")\n    \n    R2 <- cor(y, preds)^2  # R-squared metric\n    results[results$PC == pc, \"R2\"] <- R2\n  }\n  \n  return(results)\n}\n\nperformance_results <- evaluate_model_performance(models, merged_pcs, phys_selection)\nsummary(performance_results$R2)\n```\n:::\n\n\n## Results\n\nPlot results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select top 20 predictive phys features\ntop_features <- feature_importance %>% top_n(20, MeanImportance)\n\n# Plot\nggplot(top_features, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"Top 20 Predictive Phys Features\",\n       x = \"Physiological Metric\",\n       y = \"Mean Importance\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(performance_results, aes(x = PC, y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n:::\n\n\nKeep in mind that, while we ran the model with physiological predictors, we're really interested in the genes/miRNA associated with these predictors\n\nView components associated with gene/miRNA PCs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the PCA rotation (loadings) matrix from the original gene/miRNA PCA\nmerged_loadings <- pca_merged$rotation  # Each column corresponds to a PC\n\n# Convert to data frame and reshape for plotting\nmerged_loadings_df <- as.data.frame(merged_loadings) %>%\n  rownames_to_column(var = \"gene_miRNA\") %>%\n  pivot_longer(-gene_miRNA, names_to = \"Merged_PC\", values_to = \"Loading\")\n\n# View top CpGs contributing most to each PC\ntop_genes <- merged_loadings_df %>%\n  group_by(Merged_PC) %>%\n  arrange(desc(abs(Loading))) %>%\n  slice_head(n = 20)  # Select top 10 CpGs per PC\n\nprint(top_genes)\n```\n:::\n\n\nView top 20 miRNA/genes associated with PC9 (the PC with the highest R\\^2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(top_genes%>%filter(Merged_PC==\"PC9\"))\n```\n:::\n\n\nInteresting, there's an miRNA in there!\n\nView predicted vs actual gene expression values to evaluate model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_pc <- performance_results$PC[which.max(performance_results$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values <- merged_pcs[[best_pc]]\npredicted_values <- predict(models[[best_pc]], as.matrix(phys_selection), s = \"lambda.min\")\n\n# Create data frame\nprediction_df <- data.frame(\n  Actual = actual_values,\n  Predicted = predicted_values\n)\n\n# Scatter plot with regression line\nggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_pc),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n           label = paste(\"R² =\", round(max(performance_results$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n## `geom_smooth()` using formula = 'y ~ x'\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}