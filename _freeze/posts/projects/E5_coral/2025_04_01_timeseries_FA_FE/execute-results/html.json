{
  "hash": "331b727ffcd438420b9f5f82ec47dc89",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul, Functional Annotation and Enrichment Analyses\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-04-01\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\nNote that I began this work before my time off (Thurs 3/20) and finished after returning, so some portions of this post are retroactive\n\n[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/21-Apul-annotate-miRNA-mRNA-WGCNA.Rmd)\\\n[Rendered code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/21-Apul-annotate-miRNA-mRNA-WGCNA.md)\\\n[Output files](https://github.com/urol-e5/timeseries_molecular/tree/main/D-Apul/output/21-Apul-annotate-miRNA-mRNA-WGCNA)\n\nThis work is based on the mRNA-miRNA WGCNA and the correlation of WGCNA modules with traits of interest (e.g. physiological metrics, seasonal/environmental metrics). In it, I:\n\n-   Functionally annotated all WGCNA modules\n\n-   Performed functional enrichment analysis (topGO) on all WGCNA modules that are significantly correlated with a trait to inform what genes and functions are associated with phenotype and season.\n\n-   Identified overlaps in module-module correlation *and* miRanda-based putative binding to try to identify putative miRNA-mRNA interactions.\n\n-   For putative miRNA-mRNA interactions, performed functional annotation\n\n-   For putative miRNA-mRNA interactions, performed functional enrichment analysis on the genes a given miRNA putatively interacts with to investigate putative miRNA function\n\n-   For genes of interest (e.g. genes contained within modules that are significantly correlated with a trait), saved filtered gene sets, both an FA table and raw counts.\n\nFrankly, this is sooooo much data and I didn't figure out a great way to summarize all of the results in a visual or digestible way. Here a few summary figures:\n\n**Which traits have the most significantly correlated modules/genes?**\n\n![](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/21-Apul-annotate-miRNA-mRNA-WGCNA_files/figure-gfm/unnamed-chunk-28-1.png?raw=true)\n\n**For traits of interest, what biological processes are overrepresented, and what overlap is there among traits of interest?**\n\n![](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/21-Apul-annotate-miRNA-mRNA-WGCNA_files/figure-gfm/unnamed-chunk-14-1.png?raw=true)\n\nThe true value of these analyses will require identifying a trait/module/miRNA of interest and the looking at what functions are enriched for it. I've been playing around with some interaction network visualizations, similarly to what I did with the miRanda/Pcor results, but this includes many more genes and is thus much more computationally intensive and would make the visualization less helpful\n\nCode copied below in case of file path changes:\n\nAfter running WGCNA to evaluate modules of mRNA and miRNA with correlated expression, we need to functionally annotate genes to evaluate module function(s).\n\n\n\n\n\n# Load packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(topGO)\nlibrary(igraph)\nlibrary(ggraph)\n```\n:::\n\n\n# Load and format annotation files\n\nAlready annotated the A.pulchra genome as part of the `deep-dive expression` project (see [`deep-dive-expression/D-Apul/code/02-Apul-reference-annotation.Rmd`](https://github.com/urol-e5/deep-dive-expression/blob/main/D-Apul/code/02-Apul-reference-annotation.Rmd)), so we'll pull the annotation file from that\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# Can access file stored here if needed\n# https://gannet.fish.washington.edu/kdurkin1/ravenbackups/deep-dive-expression/D-Apul/output/02-Apul-reference-annotation/Apulcra-genome-mRNA-IDmapping-2024_12_12.tab\ncp ../../../deep-dive-expression/D-Apul/output/02-Apul-reference-annotation/Apulcra-genome-mRNA-IDmapping-2024_12_12.tab ../output/21-Apul-annotate-miRNA-mRNA-WGCNA\n```\n:::\n\n\nRead mapping file into R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIDmapping_dirty <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/Apulcra-genome-mRNA-IDmapping-2024_12_12.tab\", header = TRUE, sep = \"\\t\", stringsAsFactors = FALSE)\n\n# Need to remove quotations surrounding each entry\nIDmapping_locations <- IDmapping_dirty\nIDmapping_locations[] <- lapply(IDmapping_locations, function(x) gsub('^\"(.*)\"$', '\\\\1', x))\n# Remove unneeded columns \nIDmapping_locations <- IDmapping_locations %>% dplyr::select(-X, -V13)\n# Ensure there are no duplicate rows\nIDmapping_locations <- IDmapping_locations %>% distinct()\n\nhead(IDmapping_locations)\n# Looks good!\n```\n:::\n\n\nThis file shows each gene as it's genomic location. We want to use gene IDs to associate genes, so add gene IDs to this annotation table\n\nRead in file that associates each mRNA genomic location with corresponding gene ID\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmRNA_FUNids <- read.table(\"../output/05-Apul-annotate-UTRs/Apul-mRNA-FUNids.txt\", header=FALSE, col.names=c(\"location\", \"type\", \"mRNA_ID\", \"gene_ID\", \"product\"), sep=\"\\t\")\n\n# Remove unwanted text from parent column\nmRNA_FUNids$gene_ID <- gsub(\"Parent=\", \"\", mRNA_FUNids$gene_ID)\n# Only need to keep mRNA location and gene ID\nmRNA_FUNids <- mRNA_FUNids %>% dplyr::select(location, gene_ID)\n```\n:::\n\n\njoin with annotation file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nIDmapping <- left_join(IDmapping_locations, mRNA_FUNids, by = c(\"V1\" = \"location\"))\n```\n:::\n\n\n# Annotate WGCNA modules\n\nLoad file that shows which module each gene/miRNA is in\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodule_membership <- read.table(\"../output/12-Apul-miRNA-mRNA-WGCNA/WGCNA-module-membership.tab\", header = TRUE, sep = \"\\t\", stringsAsFactors = FALSE)\n```\n:::\n\n\njoin with annotation file\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodule_FA <- left_join(module_membership, IDmapping, by = c(\"gene\" = \"gene_ID\"))\n```\n:::\n\n\nMany of the genes don't have available annotations, so reduce to only keep those that are annotated (note this will also remove lncRNA and miRNA).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodule_FA_available <- module_FA[!is.na(module_FA$Gene.Ontology.IDs),]\nmodule_FA_available <- module_FA_available[module_FA_available$Gene.Ontology.IDs != \"\",]\n```\n:::\n\n\n# Functional Enrichment of modules (topGO)\n\nI want to see whether our modules of coexpressed genes/miRNA represent specific, over-represented functionalities (i.e. does any module contain more metabolism-related genes than expected?)\n\nTo do this we'll perform functional enrichment of each module using the R package topGO\n\n## Format Gene Ontology (GO) annotations\n\nWant to isolate a list of GO terms per gene\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_to_GO <- IDmapping %>% filter(!is.na(Gene.Ontology.IDs)) %>% dplyr::select(gene_ID, Gene.Ontology.IDs)\n#head(gene_to_GO)\n\n# Needs to be formatted as a named list for use in topGO\n# Convert data frame to a named list\n# gene_to_GO_list <- gene_to_GO %>%\n#   mutate(GO_terms = strsplit(Gene.Ontology.IDs, \";\")) %>%\n#   tibble::deframe()\n\ngene_to_GO_list <- setNames(\n  strsplit(as.character(gene_to_GO$Gene.Ontology.IDs), \";\"), \n  gene_to_GO$gene_ID\n)\n```\n:::\n\n\nNote: I think this means genes that had a Uniprot ID but no GO terms are excluded from this analysis\n\nDefine reference set. This should be all genes *found in our samples*, NOT all genes in the A.pulchra genome. Some genes (e.g., reproduction pathways) may not be found/expected in our samples for valid biological reasons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreference_genes <- module_membership$gene\nlength(reference_genes)\n```\n:::\n\n\n## Extract list of significant WGCNA modules\n\n\n::: {.cell}\n\n```{.r .cell-code}\nWGCNA_pvals <- read.delim(\"../output/12-Apul-miRNA-mRNA-WGCNA/pval-cor-WGCNA_module-phys_envir.tab\", header=TRUE, sep=\"\\t\")\n\n# filter to only keep rows and columns with at least one significant pval\nfiltered_rows <- WGCNA_pvals[rowSums(WGCNA_pvals < 0.05, na.rm = TRUE) > 0, ]\nWGCNA_pvals_significant <- filtered_rows[, colSums(filtered_rows < 0.05, na.rm = TRUE) > 0]\n\n# Create list of modules that are significantly correlated with at least one trait\nsignificant_modules <- row.names(WGCNA_pvals_significant)\n```\n:::\n\n\n## topGO function\n\nCreate a function to run topGO functional enrichment analysis for an input module (we'll want to use this for many modules of interest)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodule_topGO_FE <- function(module.name) {\n  \n  #Isolate genes in our input module of interest\n  genes_in_module <- module_membership %>%\n    filter(module == module.name) %>%\n    pull(gene)\n  \n  # Create factor for all reference genes, where 1 represents module membership and 0 means the gene is not in module of interest\n  gene_list <- factor(as.integer(reference_genes %in% genes_in_module))\n  names(gene_list) <- reference_genes\n  \n  # Create topGO object\n  GO_BP <- new(\"topGOdata\",\n              description = \"Functional Enrichment Analysis\", \n              ontology = \"BP\", # Biological Process\n              allGenes = gene_list,\n              annot = annFUN.gene2GO, \n              gene2GO = gene_to_GO_list)\n  \n  # Run GO enrichment test\n  GO_BP_FE <- runTest(GO_BP, algorithm = \"weight01\", statistic = \"fisher\")\n  \n  # View the results\n  GO_BP_results <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = \"Fisher\",  topNodes = 100, numChar = 51)\n  \n  # Filter by significant results\n  GO_BP_results$Fisher<-as.numeric(GO_BP_results$Fisher)\n  GO_BP_results_sig<-GO_BP_results[GO_BP_results$Fisher<0.05,]\n\n  # Return\n  print(GO_BP_results_sig)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nresults <- list()\n\nfor(module in significant_modules) {\n  # Run topGo enrichent function\n  module_results <- module_topGO_FE(module)\n  \n  # Only keep results if not empty\n  if (nrow(module_results) > 0) {\n    # note the source column\n    module_results$module <- module\n    # append to results list\n    results[[module]] <- module_results\n  }\n}\n\n# Combine all the resuts data frames into one\ncombined_GO_BP_results_sig <- do.call(rbind, results)\n\n# View\nprint(combined_GO_BP_results_sig)\n```\n:::\n\n\n## Heatmap of significant GO terms by trait\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract significant modules for each trait\nsignificant_modules_per_trait <- apply(WGCNA_pvals_significant, 2, function(x) rownames(WGCNA_pvals_significant)[x < 0.05])\n\n# Specify traits of interest\n#traits <- colnames(WGCNA_pvals_significant)\ntraits <- c(\"timepoint2\", \"timepoint3\", \"mean_Temp_mean\", \"mean_solar_rad_kwpm2_mean\", \"cumulative_rainfall_mm_mean\")\n\n# Create empty matrix to store values for hetmap\ngo_term_counts <- matrix(0, nrow = length(traits), ncol = length(unique(combined_GO_BP_results_sig$Term)))\nrownames(go_term_counts) <- traits  # Trait names\ncolnames(go_term_counts) <- unique(combined_GO_BP_results_sig$Term)  # Unique GO terms\n\n# Loop through each trait, calculate the number of significant modules enriched for each GO term\nfor (trait in traits) {\n  # Get the significant modules for this trait\n  significant_modules <- significant_modules_per_trait[[trait]]\n  \n  # Check if a module is enriched for each GO term\n  for (go_term in unique(combined_GO_BP_results_sig$Term)) {\n    # Check if the module is in the list of significant modules for the trait and if it's enriched for this GO term\n    enriched_modules <- combined_GO_BP_results_sig %>%\n      filter(Term == go_term & module %in% significant_modules) %>%\n      nrow()  # Count of modules enriched for this GO term\n    \n    # Count number of modules that contain each GO term\n    go_term_counts[trait, go_term] <- enriched_modules\n  }\n}\n\n# Convert matrix to df for plotting\ngo_term_counts_df <- as.data.frame(go_term_counts) %>%\n  rownames_to_column(\"Trait\") %>%\n  gather(key = \"GO_term\", value = \"Module_Count\", -Trait)\n\n# Truncate GO term names\n#go_term_counts_df$GO_term <- substr(go_term_counts_df$GO_term, 1, 40)\n\n# Plot\nggplot(go_term_counts_df, aes(x = Trait, y = GO_term, fill = Module_Count)) +\n  geom_tile(color = \"grey\") +  # Adds grid lines\n  scale_fill_gradient(low = \"white\", high = \"blue\") +  # Color gradient from white (low) to blue (high)\n  theme_minimal() +\n  theme(axis.text.x = element_text(size = 8, angle = 45, hjust=0.5, vjust=0.5), \n        axis.text.y = element_text(size = 8),\n        ) + \n  labs(fill = \"# of Enriched Modules\", title = \"Significant Modules Enriched for GO Terms\") +\n  theme(legend.position = \"right\")\nggsave(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/go_term_heatmap_envir_traits.png\", width = 12, height = 10, dpi = 300)\n```\n:::\n\n\n## Isolate enriched terms by associated trait(s)\n\nTerms enriched in modules correlated with TP2\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_TP2 <- significant_modules_per_trait[[\"timepoint2\"]]\nGO_TP2 <- combined_GO_BP_results_sig[combined_GO_BP_results_sig$module %in% modules_TP2,]\nGO_TP2\n```\n:::\n\n\nTerms enriched in modules correlated with TP3\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_TP3 <- significant_modules_per_trait[[\"timepoint3\"]]\nGO_TP3 <- combined_GO_BP_results_sig[combined_GO_BP_results_sig$module %in% modules_TP3,]\nGO_TP3\n```\n:::\n\n\nTerms enriched in modules correlated with temp\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_temp <- significant_modules_per_trait[[\"mean_Temp_mean\"]]\nGO_temp <- combined_GO_BP_results_sig[combined_GO_BP_results_sig$module %in% modules_temp,]\nGO_temp\n```\n:::\n\n\nTerms enriched in modules correlated with solar\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_solar <- significant_modules_per_trait[[\"mean_solar_rad_kwpm2_mean\"]]\nGO_solar <- combined_GO_BP_results_sig[combined_GO_BP_results_sig$module %in% modules_solar,]\nGO_solar\n```\n:::\n\n\nTerms enriched in modules correlated with rain\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_rain <- significant_modules_per_trait[[\"cumulative_rainfall_mm_mean\"]]\nGO_rain <- combined_GO_BP_results_sig[combined_GO_BP_results_sig$module %in% modules_rain,]\nGO_rain\n```\n:::\n\n\n# Annotate putative binding\n\nOutline:\n\n1.  Have table module pair and correlation values\n\n## Load module-module correlations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodules_cor <- read.delim(\"../output/12-Apul-miRNA-mRNA-WGCNA/WGCNA-modules-correlations.tab\", header=TRUE, sep=\"\\t\")\n# Remove instances where a module is just correlating to itself\nmodules_cor <- modules_cor[modules_cor$module_A != modules_cor$module_B,]\n```\n:::\n\n\n## Annotate whether a given module contains miRNA\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Separate module membership into only mRNA and only miRNA\nmodule_membership_mRNA <- module_membership %>% filter(grepl(\"FUN\", gene))\nmodule_membership_miRNA <- module_membership %>% filter(grepl(\"Cluster\", gene))\n\n# Expand each miRNA_module to show all contained miRNAa\nmodules_cor_miRNA <- left_join(modules_cor, module_membership_miRNA, by = c(\"module_A\" = \"module\"))\n# Rename columns appropriately\ncolnames(modules_cor_miRNA) <- c(\"miRNA_module\", \"mRNA_module\", \"correlation\", \"miRNA\")\n\n# Remove instances where the module_A (miRNA_module) doesn't contain miRNA\nmodules_cor_miRNA <- modules_cor_miRNA %>% filter(!is.na(miRNA))\n\n# Expand each mRNA module to show all contained genes\nmodules_cor_miRNA_mRNA <- left_join(modules_cor_miRNA, module_membership_mRNA, by = c(\"mRNA_module\" = \"module\"))\n```\n:::\n\n\n## ID which miRNA-mRNA pairs putatively bind\n\nLoad and format miRanda tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load ##\nmiRanda_3UTR <- read.delim(\"../output/07-Apul-miRNA-mRNA-miRanda/Apul-miRanda-3UTR-strict-parsed-geneIDs.txt\", header=FALSE, sep=\"\\t\")\n\nmiRanda_5UTR <- read.delim(\"../output/07.1-Apul-miRNA-mRNA-miRanda-additional_inputs/Apul-miRanda-5UTR_1kb-strict-parsed.txt\", header=FALSE, sep=\"\\t\")\n  \nmiRanda_mRNA <- read.delim(\"../output/07.1-Apul-miRNA-mRNA-miRanda-additional_inputs/Apul-miRanda-mRNA_full-strict-parsed.txt\", header=FALSE, sep=\"\\t\")\n\n## Format ##\n# Remove superfluous text in miRNA name column\nmiRanda_3UTR <- miRanda_3UTR %>% mutate(V1 = str_extract(V1, \"Cluster[^.]+\"))\nmiRanda_5UTR <- miRanda_5UTR %>% mutate(V1 = str_extract(V1, \"Cluster[^.]+\"))\nmiRanda_mRNA <- miRanda_mRNA %>% mutate(V1 = str_extract(V1, \"Cluster[^.]+\"))\n\n# For 5UTR and mRNA, need to add gene_IDs associated with each genomic location\n# Load and format table of 5UTR geneIDs\nFUNids_5UTR <- read.delim(\"../output/05-Apul-annotate-UTRs/Apul-5UTR-FUNids.txt\", header=FALSE, sep=\"\\t\")\nFUNids_5UTR$V4 <- gsub(\"Parent=\", \"\", FUNids_5UTR$V4)\nFUNids_5UTR <- FUNids_5UTR %>% dplyr::select(V1, V4)\n# Already have table of mRNA geneIDs\n\n# Add gene IDs to the miRanda tables\nmiRanda_5UTR <- left_join(miRanda_5UTR, FUNids_5UTR, by=c(\"V2\" = \"V1\"))\nmiRanda_mRNA <- left_join(miRanda_mRNA, mRNA_FUNids, by=c(\"V2\"=\"location\"))\n\n# Ensure no unwanted duplicate rows\nmiRanda_3UTR <- miRanda_3UTR %>% distinct()\nmiRanda_5UTR <- miRanda_5UTR %>% distinct()\nmiRanda_mRNA <- miRanda_mRNA %>% distinct()\n\n# Add column to identify whether putative binding is in 3UTR, 5UTR, or CDS\nmiRanda_3UTR$binding_loc <- \"3UTR\"\nmiRanda_5UTR$binding_loc <- \"5UTR\"\nmiRanda_mRNA$binding_loc <- \"mRNA\"\n\n# Combine into single data frame\ncolnames(miRanda_3UTR) <- c(\"V1\", \"V2\", \"V3\", \"V4\", \"V5\", \"V6\", \"V7\", \"V8\", \"V9\", \"V10\", \"binding_loc\")\ncolnames(miRanda_5UTR) <- c(\"V1\", \"V2\", \"V3\", \"V4\", \"V5\", \"V6\", \"V7\", \"V8\", \"V9\", \"V10\", \"binding_loc\")\ncolnames(miRanda_mRNA) <- c(\"V1\", \"V2\", \"V3\", \"V4\", \"V5\", \"V6\", \"V7\", \"V8\", \"V9\", \"V10\", \"binding_loc\")\nmiRanda_combined <- rbind(miRanda_3UTR, miRanda_5UTR, miRanda_mRNA)\n\nhead(miRanda_combined)\n```\n:::\n\n\nJoin with table of correlating modules and their members to annotate, for each miRNA, which of the mRNAs in its correlated module it may bind to\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Join \nmodules_cor_miRNA_mRNA_bind <- left_join(modules_cor_miRNA_mRNA, miRanda_combined, by=c(\"gene\" = \"V10\"))\n# Only keep rows where the full miRNA-mRNA interaction matches, not just the mRNA\nmodules_cor_miRNA_mRNA_bind <- modules_cor_miRNA_mRNA_bind[modules_cor_miRNA_mRNA_bind$miRNA == modules_cor_miRNA_mRNA_bind$V1,] %>% distinct()\n```\n:::\n\n\nThis is now a table that, for each module that contians miRNA (miRNA_module), shows each module it's correlated with (mRNA_module), the genes in that module, and whether that gene putatively binds with the miRNA. It still includes, though, instances of multiple putative binding positions for the same miRNA-mRNA pair. Since we just care about the high-level miRNA-mRNA pair, let's remove this level of detail\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_cor_bind <- modules_cor_miRNA_mRNA_bind %>% dplyr::select(miRNA_module, mRNA_module, correlation, miRNA, gene, binding_loc) %>% distinct()\n\nnrow(mod_cor_bind)\nnrow(mod_cor_bind[mod_cor_bind$correlation < 0,])\n```\n:::\n\n\nSo there are 41,633 instances of an miRNA putatively binding to a gene that is contained in a correlated module. 21,274 of these (roughly half) are putative binding between modules that are *negatively* correlated with each other, which is the expected behavior for canonical miRNA function.\n\n## Join with FA table to annotate each binding mRNA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmod_cor_bind_FA <- left_join(mod_cor_bind, IDmapping, by=c(\"gene\" = \"gene_ID\")) %>% distinct()\n\nnrow(mod_cor_bind_FA %>% filter(!is.na(Gene.Ontology.IDs)))\nnrow(mod_cor_bind_FA %>% filter(!is.na(Gene.Ontology.IDs) & correlation < 0))\n```\n:::\n\n\nOf these 41,633 instances of an miRNA putatively binding to a gene contained in a correlated module, only 12,367 (roughly a quarter) of the putatively bound genes are annotated with GO terms. Roughly half of the annotated genes are associated with negative module correlation.\n\n# Functional Enrichment of putative binding\n\nIn the above annotation we've functionally annotated all miRNA-mRNA pairs that are in correlated modules *and* putatively bind in the 3UTR, 5UTR and/or coding sequence (based on miRanda). The ultimate goal is to elucidate putative function of our miRNAs by evaluating the functions of the mRNAs they putatively interact with.\n\nTo aid this we can run functional enrichment on the mRNAs that each miRNA putatively interacts with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Modify topGO function for use with miRNA names\n\nmiRNA_topGO_FE <- function(miRNA.name) {\n  \n  #Isolate genes in our input module of interest\n  interacting_genes <- mod_cor_bind_FA %>%\n    filter(miRNA == miRNA.name) %>%\n    pull(gene)\n  if (length(interacting_genes) > 0) {\n    # Create factor for all reference genes, where 1 represents module membership and 0 means the gene is not in module of interest\n    gene_list <- factor(as.integer(reference_genes %in% interacting_genes))\n    names(gene_list) <- reference_genes\n    \n    str(gene_list)\n    \n    # Create topGO object\n    GO_BP <- new(\"topGOdata\",\n                description = \"Functional Enrichment Analysis\", \n                ontology = \"BP\", # Biological Process\n                allGenes = gene_list,\n                annot = annFUN.gene2GO, \n                gene2GO = gene_to_GO_list)\n    \n    # Run GO enrichment test\n    GO_BP_FE <- runTest(GO_BP, algorithm = \"weight01\", statistic = \"fisher\")\n    \n    # View the results\n    GO_BP_results <- GenTable(GO_BP, Fisher = GO_BP_FE, orderBy = \"Fisher\",  topNodes = 100, numChar = 51)\n    \n    # Filter by significant results\n    GO_BP_results$Fisher<-as.numeric(GO_BP_results$Fisher)\n    GO_BP_results_sig<-GO_BP_results[GO_BP_results$Fisher<0.05,]\n  \n    # Return\n    print(GO_BP_results_sig)\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ninteracting_miRNAs <- unique(mod_cor_bind_FA$miRNA) %>% na.omit\nresults <- list()\n\nfor(miRNA in interacting_miRNAs) {\n  # Run topGo enrichment function\n  miRNA_results <- miRNA_topGO_FE(miRNA)\n  \n  print(miRNA_results)\n  \n  # Only keep results if not empty\n  if (nrow(miRNA_results) > 0) {\n    # note the source column\n    miRNA_results$miRNA <- miRNA\n    # append to results list\n    results[[miRNA]] <- miRNA_results\n  }\n}\n\n# Combine all the resuts data frames into one\ncombined_GO_BP_results_miRNA <- do.call(rbind, results)\n\n# View\nprint(combined_GO_BP_results_miRNA)\n```\n:::\n\n\n# Summary figures\n\nBubbleplot showing number of significantly correlated modules for eacvh trait and the total genes represented by those modules\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example significance threshold\npval_threshold <- 0.05\n\n# Filter significant modules for each trait\nsignificant_modules_long <- WGCNA_pvals %>%\n  rownames_to_column(\"module\") %>%\n  pivot_longer(-module, names_to = \"Trait\", values_to = \"Pvalue\") %>%\n  filter(Pvalue < 0.05)\n\n# Count the number of significant modules per trait\nmodule_counts <- significant_modules_long %>%\n  group_by(Trait) %>%\n  summarise(NumModules = n())\n\n# Count the number of genes in significant modules\ngene_counts <- module_membership %>%\n  filter(module %in% significant_modules_long$module) %>%\n  group_by(module) %>%\n  summarise(NumGenes = n()) %>%\n  inner_join(significant_modules_long, by = \"module\") %>%\n  group_by(Trait) %>%\n  summarise(TotalGenes = sum(NumGenes))\n\n# Merge data\nplot_data <- module_counts %>%\n  left_join(gene_counts, by = \"Trait\")\n\n# Filter to certain traits if desired\n# traits <- c(\"timepoint2\", \"timepoint3\", \"mean_Temp_mean\", \"mean_solar_rad_kwpm2_mean\", \"cumulative_rainfall_mm_mean\")\n# plot_data <- plot_data[plot_data$Trait %in% traits,]\n\n# Bubble plot\nggplot(plot_data, aes(x = Trait, y = 0.5, size = TotalGenes, color = NumModules)) +\n  geom_point(alpha = 0.8) +\n  scale_color_gradient(low = \"blue\", high = \"red\") +\n  scale_size_continuous(trans = \"log10\", range = c(2, 15)) + \n  ylim(0,1) +\n  theme_classic() +\n  labs(title = \"Significant Modules per Trait\",\n       x = \"Trait\",\n       y = \"\",\n       size = \"Total Genes\",\n       color = \"Num Modules\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1),\n        axis.text.y = element_blank(),  # Hide y-axis labels\n        axis.ticks.y = element_blank())\nggsave(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/bubble_signif_modules.png\", width = 12, height = 6, dpi = 300)\n```\n:::\n\n\nInteraction network showing, for a variable of interest, all the correlated modules, their genes, and miRNA interactions\n\n1.  Which modules are in variable of interest WGCNA_pvals\\[WGCNA_pvals\\$trait \\< 0.05,\\] %\\>% rownames()\n2.  Which genes/miRNA are in each module `module_membership`\n3.  which genes each miRNA interacts with `modules_cor_miRNA_mRNA_bind` \\^includes Correlation between modules\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrait <- \"timepoint\"\n\n# Extract correlated modules\nsig_modules <- rownames(WGCNA_pvals[WGCNA_pvals$timepoint2 < 0.05, ])\n\n# Extract genes and miRNA n each module\nmodule_genes <- module_membership[module_membership$module %in% sig_modules, ]\n\n# Extract miRNA-mRNA interactions for these modules\nmiRNA_interactions <- modules_cor_miRNA_mRNA_bind[\n  modules_cor_miRNA_mRNA_bind$miRNA_module %in% sig_modules |\n  modules_cor_miRNA_mRNA_bind$mRNA_module %in% sig_modules, \n]\n\n# Create edge list for the network\n# edges <- rbind(\n#   data.frame(from = module_genes$gene, to = module_genes$module, type = \"gene-module\"),\n#   data.frame(from = miRNA_interactions$miRNA, to = miRNA_interactions$mRNA, type = \"miRNA-mRNA\"),\n#   data.frame(from = miRNA_interactions$miRNA_module, to = miRNA_interactions$mRNA_module, type = \"module-module\")\n# )\n\n# # Gene-to-Module edges (Genes and miRNAs assigned to modules)\n# edges_genes <- data.frame(\n#   from = module_membership$gene, \n#   to = module_membership$module, \n#   type = \"gene-module\",\n#   correlation = NA  # No correlation needed for membership edges\n# )\n# \n# # miRNA-Gene interaction edges (including correlation from module correlation)\n# edges_miRNA_gene <- data.frame(\n#   from = modules_cor_miRNA_mRNA_bind$miRNA, \n#   to = modules_cor_miRNA_mRNA_bind$gene, \n#   type = \"miRNA-gene\",\n#   correlation = modules_cor_miRNA_mRNA_bind$correlation  # Assign correlation value\n# )\n# \n# # Combine all edges into a single dataframe\n# edges <- rbind(edges_genes, edges_miRNA_gene) %>% distinct()\n\nedges <- data.frame(\n  from = modules_cor_miRNA_mRNA_bind$miRNA, \n  to = modules_cor_miRNA_mRNA_bind$gene, \n  type = \"miRNA-gene\",\n  correlation = modules_cor_miRNA_mRNA_bind$correlation  # Correlation between miRNA and gene parent modules\n) %>% na.omit()\n\n# Create node data frame with miRNAs and genes\nmiRNA_nodes <- data.frame(\n  name = unique(modules_cor_miRNA_mRNA_bind$miRNA),  # Unique miRNAs\n  module = modules_cor_miRNA_mRNA_bind$miRNA_module[match(unique(modules_cor_miRNA_mRNA_bind$miRNA), modules_cor_miRNA_mRNA_bind$miRNA)],  # Corresponding miRNA module\n  type = \"miRNA\"\n) %>% na.omit()\n\n\n# Create gene-node dataframe with the filtered module_membership\ngene_nodes <- data.frame(\n  name = unique(modules_cor_miRNA_mRNA_bind$gene),  # Unique genes\n  module = modules_cor_miRNA_mRNA_bind$mRNA_module[match(unique(modules_cor_miRNA_mRNA_bind$gene), modules_cor_miRNA_mRNA_bind$gene)],  # Corresponding gene module\n  type = \"gene\"\n) %>% na.omit()\n\n# Combine both miRNA and gene nodes\nnodes <- rbind(miRNA_nodes, gene_nodes)\n\n# Plot\ng <- graph_from_data_frame(edges, directed = FALSE, vertices = nodes)\n\nggraph(g, layout = \"fr\") +\n  # Nodes colored by their module (categorical)\n  geom_node_point(aes(color = module), size = 5) +\n  \n  # Edges colored by correlation (continuous)\n  geom_edge_link(aes(color = correlation), width = 1) +\n  \n  # Discrete color scale for modules\n  scale_color_manual(values = rainbow(length(unique(V(g)$module)))) +\n  \n  # Continuous gradient color scale for correlation values\n  scale_edge_color_gradient2(low = \"blue\", mid = \"white\", high = \"red\", midpoint = 0) +\n  \n  theme_void() +\n  theme(legend.position = \"bottom\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(edges, \"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/edges.csv\")\nwrite.csv(nodes, \"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/nodes.csv\")\n```\n:::\n\n\n# Save gene sets\n\nWe'll likely want to use function-specific gene sets in later analyses, so we'll save those here. Gene sets should be saved as\n\na)  a df of the genes, the WGCNA module they fall in, and the annotated GO term(s), AND\nb)  raw count matrices, with samples in the columns and genes in the rows.\n\nSets will be named for the filter applied (e.g. \"respiration\" for genes annotated with respiration-related GO terms). Note that, since these gene sets will be used with a functional focus, we'll exclude miRNAs.\n\nLoad raw gene counts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\nApul_genes <- as.data.frame(Apul_genes)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# For each trait of interest:\nfor (trait in names(significant_modules_per_trait)) {\n  \n  ## a) a df of the genes, the WGCNA module they fall in, and the annotated GO term(s)\n  # Select modules that are significantly correlated with this trait\n  trait_sig_modules <- significant_modules_per_trait[[trait]]\n  # Filter the annotated list of genes to only keep those in selected modules, keep only genes (not miRNA)\n  trait_genes_FA <- module_FA %>%\n    filter(module %in% trait_sig_modules & grepl(\"FUN\", gene))\n  \n  ## b) raw count matrices, with samples in the columns and genes in the rows. \n  # Filter the raw gene counts to keep only genes in selected modules\n  trait_gene_counts <- Apul_genes %>%\n    filter(gene_id %in% trait_genes_FA$gene)\n  \n  # Set file names\n  file_name_genes_FA <- paste0(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/\", trait, \"_genes_FA.tab\")\n  file_name_gene_counts <- paste0(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/\", trait, \"_gene_counts.tab\")\n  # Save\n  write.table(trait_genes_FA, file_name_genes_FA, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n  write.table(trait_gene_counts, file_name_gene_counts, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n}\n```\n:::\n\n\nWe also want to be able to save genes associated with functions (GO terms) of interest.\n\nFor example, Steven identified a several GO terms related to ATP production a [notebook post](https://sr320.github.io/tumbling-oysters/posts/41-Apul-GO/): - Aerobic respiration (GO:0009060) - Oxidative phosphorylation (GO:0006119) - Canonical glycolysis (GO:0061621) - Tricarboxylic Acid Cycle (GO:0006099)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List GO terms of interest (CHANGE as desired)\nGO_terms_interest <- c(\"GO:0009060\", \"GO:0006119\", \"GO:0061621\", \"GO:0006099\")\n\n# Select genes that have been functionally annotated with at least on of the listed GO terms of interest\nGO_terms_genes_FA <- module_FA %>%\n  filter(sapply(Gene.Ontology.IDs, function(x) any(sapply(GO_terms_interest, grepl, x))))\n# For these selected genes, get raw gene counts\nGO_terms_gene_counts <- Apul_genes %>%\n  filter(gene_id %in% GO_terms_genes_FA$gene)\n\n# Set file name (CHANGE as desired)\nfile_name_GO_FA <- paste0(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/\", \"ATP_production\", \"_GO_terms_genes_FA.tab\")\nfile_name_GO_counts <- paste0(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/\", \"ATP_production\", \"_GO_terms_gene_counts.tab\")\n\nwrite.table(GO_terms_genes_FA, file_name_GO_FA, row.names=FALSE, quote=FALSE, sep=\"\\t\")\nwrite.table(go_term_counts_df, file_name_GO_counts, row.names=FALSE, quote=FALSE, sep=\"\\t\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}