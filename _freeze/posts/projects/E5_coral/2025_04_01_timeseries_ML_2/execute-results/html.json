{
  "hash": "97e4b5059bc3ceb2b8241e52806b07fa",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul phenotype and gene/miRNA machine learning -- Part 2\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-04-01\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\n[Code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning.Rmd)\\\n[Rendered code](https://github.com/urol-e5/timeseries_molecular/blob/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning.md)\n\nIn [Part 1](./2025_03_31_timeseries_ML.qmd) I ran the ML model on phenotype as a predictor of gene/miRNA expression.\n\nThis time I ran the ML model with miRNA expression as the predictor and gene expression as response to investigate miRNA-mRNA interactions. Note that, due to the high number of genes, I performed dimensionality reduction, essentially summarizing genes to PCs of coexpression\n\n# Results\n\nA couple miRNA pop out as notably highly predictive of gene expression, but all of the top 20 miRNA are important\n\n![](https://github.com/urol-e5/timeseries_molecular/raw/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning_files/figure-gfm/unnamed-chunk-32-1.png)\n\nMany gene PCs are highly explained by miRNA expression, with 11 gene PCs of R^2^ \\>\\~0.75\n\n![](https://github.com/urol-e5/timeseries_molecular/raw/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning_files/figure-gfm/unnamed-chunk-33-1.png)\n\nWe can then look at which genes are included in highly predicted PCs. For example, in PC11, the most highly predicted PC, we see an R^2^ of 0.996 and extremely strong model performance\n\n![](https://github.com/urol-e5/timeseries_molecular/raw/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning_files/figure-gfm/unnamed-chunk-36-1.png)\n\nHere are the top 20 genes included in PC11:\n\n```         \n## # A tibble: 20 × 3\n## # Groups:   Genes_PC [1]\n##    gene       Genes_PC Loading\n##    <chr>      <chr>      <dbl>\n##  1 FUN_029347 PC11      0.0196\n##  2 FUN_001854 PC11     -0.0193\n##  3 FUN_025457 PC11      0.0192\n##  4 FUN_021609 PC11     -0.0190\n##  5 FUN_041974 PC11      0.0190\n##  6 FUN_008614 PC11      0.0190\n##  7 FUN_001958 PC11      0.0189\n##  8 FUN_033958 PC11      0.0189\n##  9 FUN_000394 PC11     -0.0188\n## 10 FUN_039508 PC11      0.0187\n## 11 FUN_016324 PC11     -0.0187\n## 12 FUN_001244 PC11     -0.0185\n## 13 FUN_016966 PC11     -0.0185\n## 14 FUN_004574 PC11      0.0183\n## 15 FUN_011795 PC11     -0.0181\n## 16 FUN_015171 PC11      0.0181\n## 17 FUN_009743 PC11      0.0180\n## 18 FUN_039139 PC11      0.0180\n## 19 FUN_020597 PC11      0.0180\n## 20 FUN_032877 PC11      0.0180\n```\n\nWe can also look at which miRNA most contributed to predicting expression for PC11\n\n![](https://github.com/urol-e5/timeseries_molecular/raw/main/D-Apul/code/22-Apul-miRNA-mRNA-machine-learning_files/figure-gfm/unnamed-chunk-37-1.png)\n\nWe see that, rather than a single miRNA being primarily responsible for predicting PC11 expression, many are involved with high importance, suggesting a complex interaction network\n\n### Code copied below in case of file path changes:\n\nI'd like to see whether phenotype can predict gene and/or miRNA expression, will be testing this using the ML approach Ariana has been trialing (see her mRNA-WGBS ML post here: https://ahuffmyer.github.io/ASH_Putnam_Lab_Notebook/E5-timeseries-molecular-mRNA-WGBS-machine-learning-analysis-Part-1/)\n\nInputs:\n\n-   RNA counts matrix (raw): `../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv`\n\n-   sRNA/miRNA counts matrix (raw): `../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt`\n\n-   sample metadata: `../../M-multi-species/data/rna_metadata.csv`\n\n-   physiological data: https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\n\nNote that I'll start by using phenotype (e.g. biomass, respiration) as the predictor, which is suitable for understanding *how external factors drive gene expression changes.*\n\nIf, instead, we wanted to build some sort of predictive model, where *gene expression could be used to predict phenotype*, we could switch so that gene counts are used as the predictors.\n\n# Load libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(DESeq2)\nlibrary(igraph)\nlibrary(psych)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(WGCNA)\nlibrary(edgeR)\nlibrary(reshape2)\nlibrary(ggcorrplot)\nlibrary(corrplot)\nlibrary(rvest)\nlibrary(purrr)\nlibrary(pheatmap)\nlibrary(glmnet)\nlibrary(caret)\nlibrary(factoextra)\nlibrary(vegan)\nlibrary(ggfortify)\n```\n:::\n\n\n# Load and prep data\n\nLoad in count matrices for RNAseq.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# raw gene counts data (will filter and variance stabilize)\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\nApul_genes <- as.data.frame(Apul_genes)\n\n# format gene IDs as rownames (instead of a column)\nrownames(Apul_genes) <- Apul_genes$gene_id\nApul_genes <- Apul_genes%>%select(!gene_id)\n\n\n# load and format metadata\nmetadata <- read_csv(\"../../M-multi-species/data/rna_metadata.csv\")%>%select(AzentaSampleName, ColonyID, Timepoint) %>%\n  filter(grepl(\"ACR\", ColonyID))\nmetadata$Sample <- paste(metadata$AzentaSampleName, metadata$ColonyID, metadata$Timepoint, sep = \"_\")\n\ncolonies <- unique(metadata$ColonyID)\n\n# Load physiological data\nphys<-read_csv(\"https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\")%>%filter(colony_id_corr %in% colonies)%>%\n  select(colony_id_corr, species, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, AQY, Rd, Ik, Ic, calc.umol.cm2.hr, cells.mgAFDW, prot_mg.mgafdw, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, cre.umol.mgafdw)\n# format timepoint\nphys$timepoint <- gsub(\"timepoint\", \"TP\", phys$timepoint)\n#add column with full sample info\nphys <- merge(phys, metadata, by.x = c(\"colony_id_corr\", \"timepoint\"), by.y = c(\"ColonyID\", \"Timepoint\")) %>%\n  select(-AzentaSampleName)\n  \n\n#add site information into metadata \nmetadata$Site<-phys$site[match(metadata$ColonyID, phys$colony_id_corr)]\n\n\n# Rename gene column names to include full sample info (as in miRNA table)\ncolnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]\n\n# raw miRNA counts (will filter and variance stabilize)\nApul_miRNA <- read.table(file = \"../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt\", header = TRUE, sep = \"\\t\", check.names = FALSE)\n```\n:::\n\n\n## Counts filtering\n\nEnsure there are no genes or miRNAs with 0 counts across all samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(Apul_genes)\n\nApul_genes_filt<-Apul_genes %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_genes_filt)\n\n# miRNAs\nnrow(Apul_miRNA)\n\nApul_miRNA_filt<-Apul_miRNA %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_miRNA_filt)\n```\n:::\n\n\nRemoving genes with only 0 counts reduced number from 44371 to 35869. Retained all 51 miRNAs.\n\nWill not be performing pOverA filtering for now, since LM should presumabily incorporate sample representation\n\n## Physiology filtering\n\nRun PCA on physiology data to see if there are phys outliers\n\nExport data for PERMANOVA test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest<-as.data.frame(phys)\ntest<-test[complete.cases(test), ]\n```\n:::\n\n\nBuild PERMANOVA model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_test <-prcomp(test%>%select(where(is.numeric)), scale=TRUE, center=TRUE)\nfviz_eig(scaled_test)\n\n# scale data\nvegan <- scale(test%>%select(where(is.numeric)))\n\n# PerMANOVA \npermanova<-adonis2(vegan ~ timepoint*site, data = test, method='eu')\npermanova\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npca1<-ggplot2::autoplot(scaled_test, data=test, frame.colour=\"timepoint\", loadings=FALSE,  colour=\"timepoint\", shape=\"site\", loadings.label.colour=\"black\", loadings.colour=\"black\", loadings.label=FALSE, frame=FALSE, loadings.label.size=5, loadings.label.vjust=-1, size=5) + \n  geom_text(aes(x = PC1, y = PC2, label = paste(colony_id_corr, timepoint)), vjust = -0.5)+\n  theme_classic()+\n   theme(legend.text = element_text(size=18), \n         legend.position=\"right\",\n        plot.background = element_blank(),\n        legend.title = element_text(size=18, face=\"bold\"), \n        axis.text = element_text(size=18), \n        axis.title = element_text(size=18,  face=\"bold\"));pca1\n```\n:::\n\n\nRemove ACR-173, timepoint 3 sample from analysis. This is Azenta sample 1B2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nApul_miRNA_filt <- Apul_miRNA_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B2_ACR-173_TP3\")\n```\n:::\n\n\nWe also do not have phys data for colony 1B9 ACR-265 at TP4, so I'll remove that here as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nApul_miRNA_filt <- Apul_miRNA_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B9_ACR-265_TP4\")\n```\n:::\n\n\n## Assign metadata and arrange order of columns\n\nOrder metadata the same as the column order in the gene matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist<-colnames(Apul_genes_filt)\nlist<-as.factor(list)\n\nmetadata$Sample<-as.factor(metadata$Sample)\n\n# Re-order the levels\nmetadata$Sample <- factor(as.character(metadata$Sample), levels=list)\n# Re-order the data.frame\nmetadata_ordered <- metadata[order(metadata$Sample),]\nmetadata_ordered$Sample\n\n# Make sure the miRNA colnames are also in the same order as the gene colnames\nApul_miRNA_filt <- Apul_miRNA_filt[, colnames(Apul_genes_filt)]\n```\n:::\n\n\nMetadata and gene count matrix are now ordered the same.\n\n## Conduct variance stabilized transformation\n\nVST should be performed on our two input datasets (gene counts and miRNA counts) separately\n\n### Genes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_genes <- estimateSizeFactors(dds_genes) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_genes)) #View size factors\n\nall(sizeFactors(SF.dds_genes)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes <- vst(dds_genes, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size\nvsd_genes <- assay(vsd_genes)\nhead(vsd_genes, 3) #view transformed gene count data for the first three genes in the dataset.  \n```\n:::\n\n\n### miRNA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_miRNA <- estimateSizeFactors(dds_miRNA) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_miRNA)) #View size factors\n\nall(sizeFactors(SF.dds_miRNA)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size. Using varianceStabilizingTransformation() instead of vst() because few input genes\nvsd_miRNA <- assay(vsd_miRNA)\nhead(vsd_miRNA, 3) #view transformed gene count data for the first three genes in the dataset.\n```\n:::\n\n\n## Combine counts data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract variance stabilized counts as dataframes\n# want samples in rows, genes/miRNAs in columns\nvsd_genes <- as.data.frame(t(vsd_genes))\nvsd_miRNA <- as.data.frame(t(vsd_miRNA))\n\n# Double check the row names (sample names) are in same order\nrownames(vsd_genes) == rownames(vsd_miRNA)\n\n# Combine vst gene counts and vst miRNA counts by rows (sample names)\nvsd_merged <- cbind(vsd_genes, vsd_miRNA)\n```\n:::\n\n\n# Feature selection\n\n## Genes + miRNA\n\nWe have a large number of genes, so we'll reduce dimensionality using PCA. Note that, since we only have a few phenotypes of interest, we don't need to reduce this dataset\n\nFirst need to remove any genes/miRNA that are invariant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_merged_filt <- vsd_merged[, apply(vsd_merged, 2, var) > 0]\n\nncol(vsd_merged)\nncol(vsd_merged_filt)\n\ncolnames(vsd_merged[, apply(vsd_merged, 2, var) == 0])\n```\n:::\n\n\nRemoved 74 invariant genes. I was worried we lost miRNA, but it looks like everything removed was a gene (prefix \"FUN\")!\n\nReduce dimensionality (genes+miRNA)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA on gene+miRNA expression matrix\npca_merged <- prcomp(vsd_merged_filt, scale. = TRUE)\n\n# Select top PCs that explain most variance (e.g., top 50 PCs)\nexplained_var <- summary(pca_merged)$importance[2, ]  # Cumulative variance explained\nnum_pcs <- min(which(cumsum(explained_var) > 0.95))  # Keep PCs that explain 95% variance\n\nmerged_pcs <- as.data.frame(pca_merged$x[, 1:num_pcs])  # Extract selected PCs\n\ndim(merged_pcs)\n```\n:::\n\n\nWe have 27 gene/miRNA expression PCs\n\n## Genes only\n\nTo investigate gene expression separately from miRNA expression, reduce dimensionality of genes alone.\n\nRemove any genes that are invariant\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes_filt <- vsd_genes[, apply(vsd_genes, 2, var) > 0]\n\nncol(vsd_genes)\nncol(vsd_genes_filt)\n```\n:::\n\n\nRemoved 74 invariant genes.\n\nReduce dimensionality\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA on gene expression matrix\npca_genes <- prcomp(vsd_genes_filt, scale. = TRUE)\n\n# Select top PCs that explain most variance (e.g., top 50 PCs)\nexplained_var_genes <- summary(pca_genes)$importance[2, ]  # Cumulative variance explained\nnum_pcs_genes <- min(which(cumsum(explained_var_genes) > 0.95))  # Keep PCs that explain 95% variance\n\ngenes_pcs <- as.data.frame(pca_genes$x[, 1:num_pcs_genes])  # Extract selected PCs\n\ndim(genes_pcs)\n```\n:::\n\n\n## Physiological metrics\n\nSelect physiological metrics of interest. For now we'll focus on biomass (\"Host_AFDW.mg.cm2\"), protein (\"prot_mg.mgafdw\"), and respiration (\"Rd\"). These are all metrics of host energy storage and expenditure.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assign sample IDs to row names\nrownames(phys) <- phys$Sample\n\n# Select metrics\nphys_selection <- phys %>% select(Host_AFDW.mg.cm2, prot_mg.mgafdw, Rd)\n\n# Make sure the phys rownames are in the same order as the gene/miRNA rownames\nphys_selection <- phys_selection[rownames(merged_pcs),]\n```\n:::\n\n\n# Phenotype to predict gene/miRNA expression\n\n## The model\n\nTrain elastic models to predict gene expression PCs from phys data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_models <- function(response_pcs, predictor_pcs) {\n  models <- list()\n  \n  for (pc in colnames(response_pcs)) {\n    y <- response_pcs[[pc]]  # Gene expression PC\n    X <- as.matrix(predictor_pcs)  # Phys as predictors\n    \n    # Train elastic net model (alpha = 0.5 for mix of LASSO & Ridge)\n    model <- cv.glmnet(X, y, alpha = 0.5)\n    \n    models[[pc]] <- model\n  }\n  \n  return(models)\n}\n\n# Train models predicting gene expression PCs from phys data\nmodels <- train_models(merged_pcs, phys_selection)\n```\n:::\n\n\nExtract feature importance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_feature_importance <- function(models) {\n  importance_list <- lapply(models, function(model) {\n    coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Convert to regular matrix & remove intercept\n    \n    # Convert to data frame\n    coefs_df <- data.frame(Feature = rownames(coefs), Importance = as.numeric(coefs))\n    \n    return(coefs_df)\n  })\n  \n  # Combine feature importance across all predicted gene PCs\n  importance_df <- bind_rows(importance_list) %>%\n    group_by(Feature) %>%\n    summarize(MeanImportance = mean(abs(Importance)), .groups = \"drop\") %>%\n    arrange(desc(MeanImportance))\n  \n  return(importance_df)\n}\n\nfeature_importance <- get_feature_importance(models)\nhead(feature_importance, 20)  # Top predictive phys features\n```\n:::\n\n\nEvaluate performance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nevaluate_model_performance <- function(models, response_pcs, predictor_pcs) {\n  results <- data.frame(PC = colnames(response_pcs), R2 = NA)\n  \n  for (pc in colnames(response_pcs)) {\n    y <- response_pcs[[pc]]\n    X <- as.matrix(predictor_pcs)\n    \n    model <- models[[pc]]\n    preds <- predict(model, X, s = \"lambda.min\")\n    \n    R2 <- cor(y, preds)^2  # R-squared metric\n    results[results$PC == pc, \"R2\"] <- R2\n  }\n  \n  return(results)\n}\n\nperformance_results <- evaluate_model_performance(models, merged_pcs, phys_selection)\nsummary(performance_results$R2)\n```\n:::\n\n\n## Results\n\nPlot results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select top 20 predictive phys features\ntop_features <- feature_importance %>% top_n(20, MeanImportance)\n\n# Plot\nggplot(top_features, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"Top 20 Predictive Phys Features\",\n       x = \"Physiological Metric\",\n       y = \"Mean Importance\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(performance_results, aes(x = PC, y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n:::\n\n\nKeep in mind that, while we ran the model with physiological predictors, we're really interested in the genes/miRNA associated with these predictors\n\nView components associated with gene/miRNA PCs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the PCA rotation (loadings) matrix from the original gene/miRNA PCA\nmerged_loadings <- pca_merged$rotation  # Each column corresponds to a PC\n\n# Convert to data frame and reshape for plotting\nmerged_loadings_df <- as.data.frame(merged_loadings) %>%\n  rownames_to_column(var = \"gene_miRNA\") %>%\n  pivot_longer(-gene_miRNA, names_to = \"Merged_PC\", values_to = \"Loading\")\n\n# View top CpGs contributing most to each PC\ntop_genes <- merged_loadings_df %>%\n  group_by(Merged_PC) %>%\n  arrange(desc(abs(Loading))) %>%\n  slice_head(n = 20)  # Select top 10 CpGs per PC\n\nprint(top_genes)\n```\n:::\n\n\nView top 20 miRNA/genes associated with PC9 (the PC with the highest R\\^2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(top_genes%>%filter(Merged_PC==\"PC9\"))\n```\n:::\n\n\nInteresting, there's an miRNA in there!\n\nView predicted vs actual gene expression values to evaluate model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_pc <- performance_results$PC[which.max(performance_results$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values <- merged_pcs[[best_pc]]\npredicted_values <- predict(models[[best_pc]], as.matrix(phys_selection), s = \"lambda.min\")\n\n# Create data frame\nprediction_df <- data.frame(\n  Actual = actual_values,\n  Predicted = predicted_values\n)\n\n# Scatter plot with regression line\nggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_pc),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n           label = paste(\"R² =\", round(max(performance_results$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n## `geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n\n# miRNA expression to predict gene expression\n\n## The model\n\nTrain elastic models to predict gene expression PCs from phys data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Train models predicting gene expression PCs from phys data\nmodels2 <- train_models(genes_pcs, vsd_miRNA)\n```\n:::\n\n\nExtract feature importance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeature_importance2 <- get_feature_importance(models2)\nhead(feature_importance2, 20)  # Top predictive phys features\n```\n:::\n\n\nEvaluate performance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperformance_results2 <- evaluate_model_performance(models2, genes_pcs, vsd_miRNA)\nsummary(performance_results2$R2)\n```\n:::\n\n\n## Results\n\nPlot results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select top 20 predictive phys features\ntop_features2 <- feature_importance2 %>% top_n(20, MeanImportance)\n\n# Plot\nggplot(top_features2, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"Top 20 Predictive miRNA Features\",\n       x = \"Gene Expression\",\n       y = \"Mean Importance\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(performance_results2, aes(x = PC, y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results2$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n:::\n\n\nView components associated with gene PCs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the PCA rotation (loadings) matrix from the original gene PCA\ngenes_loadings <- pca_genes$rotation  # Each column corresponds to a PC\n\n# Convert to data frame and reshape for plotting\ngenes_loadings_df <- as.data.frame(genes_loadings) %>%\n  rownames_to_column(var = \"gene\") %>%\n  pivot_longer(-gene, names_to = \"Genes_PC\", values_to = \"Loading\")\n\n# View top genes contributing most to each PC\ntop_genes2 <- genes_loadings_df %>%\n  group_by(Genes_PC) %>%\n  arrange(desc(abs(Loading))) %>%\n  slice_head(n = 20)  # Select top 10 CpGs per PC\n\nprint(top_genes2)\n```\n:::\n\n\nView top 20 genes associated with PC11 (the most \"predictable\" PC, with the highest R\\^2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(top_genes2%>%filter(Genes_PC==\"PC11\"))\n```\n:::\n\n\nView predicted vs actual gene expression values to evaluate model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_pc2 <- performance_results2$PC[which.max(performance_results2$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values2 <- genes_pcs[[best_pc2]]\npredicted_values2 <- predict(models2[[best_pc2]], as.matrix(vsd_miRNA), s = \"lambda.min\")\n\n# Create data frame\nprediction_df2 <- data.frame(\n  Actual = actual_values2,\n  Predicted = predicted_values2\n)\n\n# Scatter plot with regression line\nggplot(prediction_df2, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_pc2),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values2), y = max(predicted_values2), \n           label = paste(\"R² =\", round(max(performance_results2$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n## `geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n\nWe can also look att which miRNA(s) contributed most to predicting gene PCs of interest\n\n\n::: {.cell}\n\n```{.r .cell-code}\n get_feature_importance_for_pc <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\n# Extract feature importance for the most predictable PC\n#best_pc2 <- \"PC11\"\nbest_pc_model2 <- models2[[best_pc2]]\nbest_pc_importance2 <- get_feature_importance_for_pc(best_pc_model2)\n\n# View top most important miRNA for predicting this PC\nprint(head(best_pc_importance2, 10))\n\n# Plot\nggplot(best_pc_importance2 %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +\n  theme_minimal() +\n  labs(title = paste(\"Top miRNA Predictors for\", best_pc2),\n       x = \"miRNA\",\n       y = \"Importance Score\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}