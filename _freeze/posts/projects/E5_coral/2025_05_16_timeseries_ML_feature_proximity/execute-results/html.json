{
  "hash": "180490152ebef4f860d42840b73a4571",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul, multiomic features to predict expression. Machine learning -- Feature Proximity\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-05-16\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\nLoad libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(tidyverse)\n```\n:::\n\n\n# Load\n\nLoad feature gtfs\n\n\n::: {.cell}\n\n```{.bash .cell-code}\n# A.pulchra genome gtf\ncurl -L https://github.com/urol-e5/timeseries_molecular/raw/refs/heads/main/D-Apul/output/02.20-D-Apul-RNAseq-alignment-HiSat2/Apulchra-genome.stringtie.gtf -o ./output/2025_05_16_timeseries_ML_feature_proximity/Apulchra-genome.stringtie.gtf\n\n# A.pulchra lncRNA gtf\ncurl -L https://github.com/urol-e5/timeseries_molecular/raw/refs/heads/main/D-Apul/output/08-Apul-lncRNA/lncRNAs.gtf -o ./output/2025_05_16_timeseries_ML_feature_proximity/lncRNA.gtf\n\n# A.pulchra sRNA gff3 (contains all sRNA with notations -- will need to filter to retain only valid miRNA)\ncurl -L https://github.com/urol-e5/timeseries_molecular/raw/refs/heads/main/D-Apul/output/04-Apul-sRNA-discovery-ShortStack/ShortStack_out/Results.gff3 -o ./output/2025_05_16_timeseries_ML_feature_proximity/sRNA.gff3\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\n# A.pulchra CpG gtf (DNA methylation)\n# Prohibitively large number of total CpGs, so will only load CpGs we retained for ML model\n# Note that this is a counts table, but CpG coordinates are stored in their names\ncurl -L https://github.com/urol-e5/timeseries_molecular/raw/refs/heads/main/D-Apul/output/22.2-Apul-multiomic-machine-learning/filtered-WGBS-CpG-counts.csv -o ./output/2025_05_16_timeseries_ML_feature_proximity/filtered-WGBS-CpG-counts.csv\n\n```\n:::\n\n\nLoad df of well-predicted energetic state genes and their respective top predictors\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncurl -L https://github.com/urol-e5/timeseries_molecular/raw/refs/heads/main/D-Apul/output/22.3-Apul-multiomic-machine-learning-byTP/top_predictors.csv -o ./output/2025_05_16_timeseries_ML_feature_proximity/top_predictors.csv\n```\n:::\n\n\nConvert the predictor csv to a tab-delimited file (easier to use with the gtf/gffs in bash)\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ./output/2025_05_16_timeseries_ML_feature_proximity\n\nawk -F',' '{\n    for (i = 1; i <= NF; i++) {\n        gsub(/^\"|\"$/, \"\", $i)  # remove surrounding double quotes\n        gsub(/\"\"/, \"\\\"\", $i)   # handle escaped quotes if needed\n    }\n    OFS = \"\\t\"\n    print $0\n}' top_predictors.csv > top_predictors.tab\n```\n:::\n\n\n# Isolate\n\nFilter genome gtf to obtain gtf of well-predicted genes\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ./output/2025_05_16_timeseries_ML_feature_proximity\n\n# Will only keep genome gtf entries that contain one of the genes listed in top_predictors.tab\n\n# Extract column 3 values (well-predicted genes) from the reference file, skipping the header\ntail -n +2 top_predictors.tab | cut -f3 | sort -u > well_predicted.txt\n\n\n# Filter the GTF file using grep\ngrep -Ff well_predicted.txt Apulchra-genome.stringtie.gtf > well-predicted-genes.gtf\n\n# Remove intermediate file\nrm well_predicted.txt\n```\n:::\n\n\nFilter lncRNA gtf to isolate those that are top predictors of our genes of interest\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ./output/2025_05_16_timeseries_ML_feature_proximity\n\n# Will only keep genome gtf entries that contain one of the lncRNA listed in top_predictors.tab\n\n# Extract column 1 (predictors), skip the header, and filter for entries containing 'lncRNA'\ntail -n +2 top_predictors.tab | cut -f1 | grep 'lncRNA' | sort -u > predictive_lncRNA.txt\n\n# Use grep to filter the GTF file based on these patterns\ngrep -Fwf predictive_lncRNA.txt lncRNA.gtf > predictive_lncRNA.gtf\n\n# Remove intermediate file\nrm predictive_lncRNA.txt\n```\n:::\n\n\nFilter miRNA gff3 to obtain a gff of all miRNA and a gff of our predicitve miRNA\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ./output/2025_05_16_timeseries_ML_feature_proximity\n\n# Only keep sRNA entries that are valid miRNA (MIRNA=Y)\ngrep 'MIRNA=Y' sRNA.gff3 > mirna.gff3\n\n# Extract miRNA that are top predictors\n# Extract column 1 (predictors), skip the header, and filter for entries containing 'Cluster'\ntail -n +2 top_predictors.tab | cut -f1 | grep 'Cluster' | sort -u > predictive_miRNA.txt\n\n# Use grep to filter the GTF file based on these patterns\ngrep -Fwf predictive_miRNA.txt sRNA.gff3 > predictive_miRNA.gff3\n\n# Remove intermediate file\nrm predictive_miRNA.txt\n```\n:::\n\n\nFrom the CpG counts matrix, obtain a bed file of all considered CpGs and a bed file of predictive CpGs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read in csv and isolate the CpG names\nCpG_counts <- read.csv(\"./output/2025_05_16_timeseries_ML_feature_proximity/filtered-WGBS-CpG-counts.csv\")\n\nall_CpGs <- CpG_counts$X\n\n# Extract chromosome and position using regex\nchrom <- sub(\"^CpG_(.+)_\\\\d+$\", \"\\\\1\", all_CpGs)\npos   <- as.numeric(sub(\".*_(\\\\d+)$\", \"\\\\1\", all_CpGs))\n\n# Construct BED-format data frame\nbed <- data.frame(\n  chrom = chrom,\n  start = pos - 1,    # BED is 0-based\n  end   = pos,\n  name  = all_CpGs         # name column\n)\n\n# Write to BED file\nwrite.table(bed, file = \"./output/2025_05_16_timeseries_ML_feature_proximity/CpGs.bed\", sep = \"\\t\", quote = FALSE, row.names = FALSE, col.names = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ./output/2025_05_16_timeseries_ML_feature_proximity\n\n# Will only keep CpG bed entries that contain one of the CpGs listed in top_predictors.tab\n\n# Extract column 1 (predictors), skip the header, and filter for entries containing 'lncRNA'\ntail -n +2 top_predictors.tab | cut -f1 | grep 'CpG' | sort -u > predictive_CpGs.txt\n\n# Use grep to filter the GTF file based on these patterns\ngrep -Fwf predictive_CpGs.txt CpGs.bed > predictive_CpGs.bed\n\n# Remove intermediate file\nrm predictive_CpGs.txt\n```\n:::\n\n\n# Gene feature files\n\nI also want a feature file for each gene, that contains coordinate information for that gene and its top predictors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load predictor table\npreds <- read.table(\"./output/2025_05_16_timeseries_ML_feature_proximity/top_predictors.tab\", header=TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#Load annotations\nall_genes_gtf <- read.table(\"./output/2025_05_16_timeseries_ML_feature_proximity/Apulchra-genome.stringtie.gtf\", sep=\"\\t\", col.names=c(\"scaffold\", \"V2\", \"V3\", \"start\", \"end\", \"V6\", \"V7\", \"V8\", \"info\"))\nall_lncrna_gtf <- read.table(\"./output/2025_05_16_timeseries_ML_feature_proximity/lncrna.gtf\", sep=\"\\t\", col.names=c(\"scaffold\", \"V2\", \"V3\", \"start\", \"end\", \"V6\", \"V7\", \"V8\", \"info\"))\nall_mirna_gff3 <- read.table(\"./output/2025_05_16_timeseries_ML_feature_proximity/miRNA.gff3\", sep=\"\\t\", col.names=c(\"scaffold\", \"V2\", \"V3\", \"start\", \"end\", \"V6\", \"V7\", \"V8\", \"info\"))\nall_cpg_bed <- read.table(\"./output/2025_05_16_timeseries_ML_feature_proximity/CpGs.bed\", col.names=c(\"scaffold\", \"start\", \"end\", \"info\"))\n\n#For non-bed files, need to convert 1-start positions to 0-start positions\nall_genes_gtf$start_bed <- all_genes_gtf$start - 1\nall_lncrna_gtf$start_bed <- all_lncrna_gtf$start - 1\nall_mirna_gff3$start_bed <- all_mirna_gff3$start - 1\nall_cpg_bed$start_bed <- all_cpg_bed$start\n\n# Column with just the feature ID\nall_genes_gtf$ID <- str_extract(all_genes_gtf$info, \"(?<=ref_gene_id )[^;]+\")\nall_lncrna_gtf$ID <- str_extract(all_lncrna_gtf$info, \"(?<=gene_id )[^;]+\")\nall_mirna_gff3$ID <- str_extract(all_mirna_gff3$info, \"(?<=ID=)[^;]+\")\nall_cpg_bed$ID <- all_cpg_bed$info\n\n\n# Remove superfluous features (e.g. gene exon notes, miRNA star and precursor) and save bed style columns\nall_genes_bed <- all_genes_gtf[all_genes_gtf$V3 == \"transcript\",] %>% select(scaffold, start_bed, end, ID)\nall_lncrna_bed <- all_lncrna_gtf %>% select(scaffold, start_bed, end, ID)\nall_mirna_bed <- all_mirna_gff3%>% select(scaffold, start_bed, end, ID)\nall_cpg_bed <- all_cpg_bed %>% select(scaffold, start_bed, end, ID)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# For each unique feature\nfor (feat in unique(preds$Feature)) {\n\n  # Get predictors for this feature\n  pred_ids <- preds %>% filter(Feature == feat) %>% pull(Predictor)\n\n  # Group predictors by type using pattern matching (still grepl for this part)\n  lnc_ids <- pred_ids[grepl(\"^lncRNA_\", pred_ids)]\n  mir_ids <- pred_ids[grepl(\"^Cluster_\", pred_ids)]\n  cpg_ids <- pred_ids[grepl(\"^CpG_\", pred_ids)]\n\n  # Get ranges for feature and its predictors using exact ID matching\n  feat_range <- all_genes_bed %>% filter(ID == feat)\n  lnc_ranges <- if (length(lnc_ids) > 0) all_lncrna_bed %>% filter(ID %in% lnc_ids) else NULL\n  mirna_ranges <- if (length(mir_ids) > 0) all_mirna_bed %>% filter(ID %in% mir_ids) else NULL\n  cpg_ranges <- if (length(cpg_ids) > 0) all_cpg_bed %>% filter(ID %in% cpg_ids) else NULL\n\n  # Combine all into one BED-like table\n  bed_df <- dplyr::bind_rows(\n    as.data.frame(feat_range) %>% select(scaffold, start_bed, end, ID),\n    as.data.frame(lnc_ranges),\n    as.data.frame(mirna_ranges),\n    as.data.frame(cpg_ranges)\n  )\n\n  # Write to BED\n  out_file <- paste0(\"./output/2025_05_16_timeseries_ML_feature_proximity/\", feat, \"_with_predictors.bed\")\n  write.table(bed_df, out_file, row.names = FALSE, col.names = FALSE, quote = FALSE)\n}\n```\n:::\n\n\n# Feature files for binding-based interactions\n\nRead in cytoscape edges file, which shows all miRNA interactions with binding and PCC information\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninteractions <- read.csv(\"./output/2025_04_28_timeseries_cytoscape_files/edges_PCC_0.5_timeseries_miRNA_lncRNA_genes.csv\") %>% select(source, target, PCC.cor) %>% distinct()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (mirna in unique(interactions$source)) {\n  # Get interactions for this feature\n  inter_ids <- interactions %>% filter(source == mirna) %>% pull(target)\n\n  # Group interactions by type\n  lnc_ids <- inter_ids[grepl(\"^lncRNA_\", inter_ids)]\n  gene_ids <- inter_ids[grepl(\"^FUN_\", inter_ids)]\n\n  # Get ranges for feature and its predictors using exact matches\n  mirna_range <- all_mirna_bed %>% filter(ID == mirna)\n  \n  lnc_ranges <- if (length(lnc_ids) > 0) lncrna_bed %>% filter(ID %in% lnc_ids) else NULL\n  gene_ranges <- if (length(gene_ids) > 0) all_genes_bed %>% filter(ID %in% gene_ids) else NULL\n\n  # Combine all into one BED-like table\n  bed_df <- dplyr::bind_rows(\n    as.data.frame(mirna_range),\n    as.data.frame(lnc_ranges),\n    as.data.frame(gene_ranges)\n  )\n\n  # Write to BED\n  out_file <- paste0(\"./output/2025_05_16_timeseries_ML_feature_proximity/\", mirna, \"_with_interactions.bed\")\n  write.table(bed_df, out_file, row.names = FALSE, col.names = FALSE, quote = FALSE)\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}