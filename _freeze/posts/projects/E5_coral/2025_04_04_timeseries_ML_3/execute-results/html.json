{
  "hash": "7d5a7eb2f42b5a841ba7f6fea53ef714",
  "result": {
    "markdown": "---\ntitle: \"Timeseries molecular: A.pul phenotype and gene/miRNA machine learning -- Part 3\"\nauthor: \"Kathleen Durkin\"\ndate: \"2025-04-04\"\ncategories: [\"E5-coral\"]\nformat:\n  html:\n    toc: true\nexecute: \n  eval: FALSE\nengine: knitr\nbibliography: ../../../references.bib\n---\n\n\nNow running model using miRNA as predictors, and specific sets of genes as response.\n\n### Code included below in case of file changes\n\nApplying ML model using smaller, specific gene sets (e.g. genes significantly correlated with a phys metric, genes with a specific known function). Also adding in pOverA filtering\n\nInputs:\n\n-   RNA counts matrix (raw): `../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv`\n\n-   Gene sets of interest: `../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/`\n\n-   sRNA/miRNA counts matrix (raw): `../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt`\n\n-   sample metadata: `../../M-multi-species/data/rna_metadata.csv`\n\n-   physiological data: <https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv>\n\nNote that I'll start by using phenotype (e.g. biomass, respiration) as the predictor, which is suitable for understanding *how external factors drive gene expression changes.*\n\nIf, instead, we wanted to build some sort of predictive model, where *gene expression could be used to predict phenotype*, we could switch so that gene counts are used as the predictors.\n\n# Load libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(DESeq2)\nlibrary(igraph)\nlibrary(psych)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(WGCNA)\nlibrary(edgeR)\nlibrary(reshape2)\nlibrary(ggcorrplot)\nlibrary(corrplot)\nlibrary(rvest)\nlibrary(purrr)\nlibrary(pheatmap)\nlibrary(glmnet)\nlibrary(caret)\nlibrary(factoextra)\nlibrary(vegan)\nlibrary(ggfortify)\nlibrary(genefilter)\n```\n:::\n\n\n# Load and prep data\n\nLoad in count matrices for RNAseq.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# raw gene counts data (will filter and variance stabilize)\nApul_genes <- read_csv(\"../output/02.20-D-Apul-RNAseq-alignment-HiSat2/apul-gene_count_matrix.csv\")\nApul_genes <- as.data.frame(Apul_genes)\n\n# format gene IDs as rownames (instead of a column)\nrownames(Apul_genes) <- Apul_genes$gene_id\nApul_genes <- Apul_genes%>%select(!gene_id)\n\n\n# load and format metadata\nmetadata <- read_csv(\"../../M-multi-species/data/rna_metadata.csv\")%>%select(AzentaSampleName, ColonyID, Timepoint) %>%\n  filter(grepl(\"ACR\", ColonyID))\nmetadata$Sample <- paste(metadata$AzentaSampleName, metadata$ColonyID, metadata$Timepoint, sep = \"_\")\n\ncolonies <- unique(metadata$ColonyID)\n\n# Load physiological data\nphys<-read_csv(\"https://github.com/urol-e5/timeseries/raw/refs/heads/master/time_series_analysis/Output/master_timeseries.csv\")%%filter(colony_id_corr %in% colonies)%>%\n  select(colony_id_corr, species, timepoint, site, Host_AFDW.mg.cm2, Sym_AFDW.mg.cm2, Am, AQY, Rd, Ik, Ic, calc.umol.cm2.hr, cells.mgAFDW, prot_mg.mgafdw, Ratio_AFDW.mg.cm2, Total_Chl, Total_Chl_cell, cre.umol.mgafdw)\n# format timepoint\nphys$timepoint <- gsub(\"timepoint\", \"TP\", phys$timepoint)\n#add column with full sample info\nphys <- merge(phys, metadata, by.x = c(\"colony_id_corr\", \"timepoint\"), by.y = c(\"ColonyID\", \"Timepoint\")) %>%\n  select(-AzentaSampleName)\n  \n\n#add site information into metadata \nmetadata$Site<-phys$site[match(metadata$ColonyID, phys$colony_id_corr)]\n\n\n# Rename gene column names to include full sample info (as in miRNA table)\ncolnames(Apul_genes) <- metadata$Sample[match(colnames(Apul_genes), metadata$AzentaSampleName)]\n\n# raw miRNA counts (will filter and variance stabilize)\nApul_miRNA <- read.table(file = \"../output/03.10-D-Apul-sRNAseq-expression-DESeq2/Apul_miRNA_ShortStack_counts_formatted.txt\", header = TRUE, sep = \"\\t\", check.names = FALSE)\n```\n:::\n\n\n## Counts filtering\n\nNote: I'm filtering (removing unrepresented and lowly-represented genes) and variance stabilizing *before* I isolate specific gene sets. Not sure if the preliminary vst is appropriate though?\n\nEnsure there are no genes or miRNAs with 0 counts across all samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnrow(Apul_genes)\n\nApul_genes_red<-Apul_genes %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_genes_red)\n\n# miRNAs\nnrow(Apul_miRNA)\n\nApul_miRNA_red<-Apul_miRNA %>%\n     mutate(Total = rowSums(.[, 1:40]))%>%\n    filter(!Total==0)%>%\n    dplyr::select(!Total)\n\nnrow(Apul_miRNA_red)\n```\n:::\n\n\nRemoving genes with only 0 counts reduced number from 44371 to 35869. Retained all 51 miRNAs.\n\n*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Setting 3/38 = 0.08. This would retain genes that are only expressed in a single season in a couple of the colonies. Additionally, setting the minimum count so that the minimum number of samples must have a gene count above a certain threshold.\n\ngenes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilt <- filterfun(pOverA(0.08, 5))\n\n#create filter for the counts data\ngfilt <- genefilter(Apul_genes_red, filt)\n\n#identify genes to keep by count filter\ngkeep <- Apul_genes_red[gfilt,]\n\n#identify gene lists\ngn.keep <- rownames(gkeep)\n\n#gene count data filtered in PoverA, P percent of the samples have counts over A\nApul_genes_filt <- as.data.frame(Apul_genes_red[which(rownames(Apul_genes_red) %in% gn.keep),])\n\n#How many rows do we have before and after filtering?\nnrow(Apul_genes_red) #Before\nnrow(Apul_genes_filt) #After\n```\n:::\n\n\nWe had 35869 genes before, and 25730 genes after filtering.\n\nmiRNA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmifilt <- filterfun(pOverA(0.08, 5))\n\n#create filter for the counts data\nmifilt <- genefilter(Apul_miRNA_red, mifilt)\n\n#identify genes to keep by count filter\nmikeep <- Apul_miRNA_red[mifilt,]\n\n#identify genes to keep by count filter\nmikeep <- Apul_miRNA_red[mifilt,]\n\n#identify gene lists\nmi.keep <- rownames(mikeep)\n\n#gene count data filtered in PoverA, P percent of the samples have counts over A\nApul_miRNA_filt <- as.data.frame(Apul_miRNA_red[which(rownames(Apul_miRNA_red) %in% mi.keep),])\n\n#How many rows do we have before and after filtering?\nnrow(Apul_miRNA_red) #Before\nnrow(Apul_miRNA_filt) #After\n```\n:::\n\n\nOf the 51 miRNA, 47 were retained. Which were removed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetdiff(rownames(Apul_miRNA_red), rownames(Apul_miRNA_filt))\n```\n:::\n\n\n## Physiology filtering\n\nRun PCA on physiology data to see if there are phys outliers\n\nExport data for PERMANOVA test.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest<-as.data.frame(phys)\ntest<-test[complete.cases(test), ]\n```\n:::\n\n\nBuild PERMANOVA model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscaled_test <-prcomp(test%>%select(where(is.numeric)), scale=TRUE, center=TRUE)\nfviz_eig(scaled_test)\n\n# scale data\nvegan <- scale(test%>%select(where(is.numeric)))\n\n# PerMANOVA \npermanova<-adonis2(vegan ~ timepoint*site, data = test, method='eu')\npermanova\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npca1<-ggplot2::autoplot(scaled_test, data=test, frame.colour=\"timepoint\", loadings=FALSE,  colour=\"timepoint\", shape=\"site\", loadings.label.colour=\"black\", loadings.colour=\"black\", loadings.label=FALSE, frame=FALSE, loadings.label.size=5, loadings.label.vjust=-1, size=5) + \n  geom_text(aes(x = PC1, y = PC2, label = paste(colony_id_corr, timepoint)), vjust = -0.5)+\n  theme_classic()+\n   theme(legend.text = element_text(size=18), \n         legend.position=\"right\",\n        plot.background = element_blank(),\n        legend.title = element_text(size=18, face=\"bold\"), \n        axis.text = element_text(size=18), \n        axis.title = element_text(size=18,  face=\"bold\"));pca1\n```\n:::\n\n\nRemove ACR-173, timepoint 3 sample from analysis. This is Azenta sample 1B2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nApul_miRNA_filt <- Apul_miRNA_filt %>%\n  select(!`1B2_ACR-173_TP3`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B2_ACR-173_TP3\")\n```\n:::\n\n\nWe also do not have phys data for colony 1B9 ACR-265 at TP4, so I'll remove that here as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nApul_genes_filt <- Apul_genes_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nApul_miRNA_filt <- Apul_miRNA_filt%>%\n  select(!`1B9_ACR-265_TP4`)\n\nmetadata <- metadata %>%\n  filter(Sample != \"1B9_ACR-265_TP4\")\n```\n:::\n\n\n## Assign metadata and arrange order of columns\n\nOrder metadata the same as the column order in the gene matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist<-colnames(Apul_genes_filt)\nlist<-as.factor(list)\n\nmetadata$Sample<-as.factor(metadata$Sample)\n\n# Re-order the levels\nmetadata$Sample <- factor(as.character(metadata$Sample), levels=list)\n# Re-order the data.frame\nmetadata_ordered <- metadata[order(metadata$Sample),]\nmetadata_ordered$Sample\n\n# Make sure the miRNA colnames are also in the same order as the gene colnames\nApul_miRNA_filt <- Apul_miRNA_filt[, colnames(Apul_genes_filt)]\n```\n:::\n\n\nMetadata and gene count matrix are now ordered the same.\n\n## Conduct variance stabilized transformation\n\nVST should be performed on our two input datasets (gene counts and miRNA counts) separately\n\nGenes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_genes <- DESeqDataSetFromMatrix(countData = Apul_genes_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_genes <- estimateSizeFactors(dds_genes) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_genes)) #View size factors\n\nall(sizeFactors(SF.dds_genes)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes <- vst(dds_genes, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size\nvsd_genes <- assay(vsd_genes)\nhead(vsd_genes, 3) #view transformed gene count data for the first three genes in the dataset.  \n```\n:::\n\n\nmiRNA:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Set DESeq2 design\ndds_miRNA <- DESeqDataSetFromMatrix(countData = Apul_miRNA_filt,\n                              colData = metadata_ordered,\n                              design = ~Timepoint+ColonyID)\n```\n:::\n\n\nCheck size factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSF.dds_miRNA <- estimateSizeFactors(dds_miRNA) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst\nprint(sizeFactors(SF.dds_miRNA)) #View size factors\n\nall(sizeFactors(SF.dds_miRNA)) < 4\n```\n:::\n\n\nAll size factors are less than 4, so we can use VST transformation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_miRNA <- varianceStabilizingTransformation(dds_miRNA, blind=TRUE) #apply a variance stabilizing transformation to minimize effects of small counts and normalize with respect to library size. Using varianceStabilizingTransformation() instead of vst() because few input genes\nvsd_miRNA <- assay(vsd_miRNA)\nhead(vsd_miRNA, 3) #view transformed gene count data for the first three genes in the dataset.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_genes <- as.data.frame(t(vsd_genes))\nvsd_miRNA <- as.data.frame(t(vsd_miRNA))\n```\n:::\n\n\n## Islolate gene sets\n\nRead in gene set tables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# genes from WGCNA modules significantly correlated with host biomass\nHost_AFDW <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Host_AFDW.mg.cm2_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n# genes from WGCNA modules significantly correlated with symbiont photosynthesis\nAm <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/Am_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n# GO temrs related to energy production\nATP_production_GO <- read.table(\"../output/21-Apul-annotate-miRNA-mRNA-WGCNA/filtered-gene-sets/ATP_production_GO_terms_gene_counts.tab\", sep=\"\\t\", header=TRUE)\n```\n:::\n\n\nIsolate filtered counts by gene set\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvsd_Host_AFDW <- vsd_genes[, colnames(vsd_genes) %in% Host_AFDW$gene_id]\nvsd_Am <- vsd_genes[, colnames(vsd_genes) %in% Am$gene_id]\n#vsd_ATP_production_GO <- vsd_genes[, colnames(vsd_genes_ %in% ATP_production_GO$gene_id)]\n```\n:::\n\n\n# Feature selection\n\nFor gene sets that are large we'll need to reduce dimensionality using PCA. Note that the \\# of miRNA (47 after filtering) is low enough that reduction isn't necessary.\n\n## Host_AFDW\n\nReduce dimensionality (genes+miRNA)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Perform PCA on gene+miRNA expression matrix\npca_Host_AFDW <- prcomp(vsd_Host_AFDW, scale. = TRUE)\n\n# Select top PCs that explain most variance (e.g., top 50 PCs)\nexplained_var_Host_AFDW <- summary(pca_Host_AFDW)$importance[2, ]  # Cumulative variance explained\nnum_pcs_Host_AFDW <- min(which(cumsum(explained_var_Host_AFDW) > 0.95))  # Keep PCs that explain 95% variance\n\nHost_AFDW_pcs <- as.data.frame(pca_Host_AFDW$x[, 1:num_pcs_Host_AFDW])  # Extract selected PCs\n\ndim(Host_AFDW_pcs)\n```\n:::\n\n\nWe have 27 gene/miRNA expression PCs\n\n# The model\n\nTrain elastic models to predict gene expression PCs from phys data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_models <- function(response_pcs, predictor_pcs) {\n  models <- list()\n  \n  for (pc in colnames(response_pcs)) {\n    y <- response_pcs[[pc]]  # Gene expression PC\n    X <- as.matrix(predictor_pcs)  # Phys as predictors\n    \n    # Train elastic net model (alpha = 0.5 for mix of LASSO & Ridge)\n    model <- cv.glmnet(X, y, alpha = 0.5)\n    \n    models[[pc]] <- model\n  }\n  \n  return(models)\n}\n\n# Train models predicting gene expression PCs from phys data\nmodels <- train_models(Host_AFDW_pcs, vsd_miRNA)\n```\n:::\n\n\nExtract feature importance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_feature_importance <- function(models) {\n  importance_list <- lapply(models, function(model) {\n    coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Convert to regular matrix & remove intercept\n    \n    # Convert to data frame\n    coefs_df <- data.frame(Feature = rownames(coefs), Importance = as.numeric(coefs))\n    \n    return(coefs_df)\n  })\n  \n  # Combine feature importance across all predicted gene PCs\n  importance_df <- bind_rows(importance_list) %>%\n    group_by(Feature) %>%\n    summarize(MeanImportance = mean(abs(Importance)), .groups = \"drop\") %>%\n    arrange(desc(MeanImportance))\n  \n  return(importance_df)\n}\n\nfeature_importance <- get_feature_importance(models)\nhead(feature_importance, 20)  # Top predictive phys features\n```\n:::\n\n\nEvaluate performance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# evaluate_model_performance <- function(models, response_pcs, predictor_pcs) {\n#   results <- data.frame(PC = colnames(response_pcs), R2 = NA)\n#   \n#   for (pc in colnames(response_pcs)) {\n#     y <- response_pcs[[pc]]\n#     X <- as.matrix(predictor_pcs)\n#     \n#     model <- models[[pc]]\n#     preds <- predict(model, X, s = \"lambda.min\")\n#     \n#     R2 <- cor(y, preds)^2  # R-squared metric\n#     results[results$PC == pc, \"R2\"] <- R2\n#   }\n#   \n#   return(results)\n# }\n\nevaluate_model_performance <- function(models, response_pcs, predictor_pcs) {\n  results <- data.frame(PC = colnames(response_pcs), R2 = NA)\n  \n  for (pc in colnames(response_pcs)) {\n    cat(\"Processing:\", pc, \"\\n\")\n    \n    y <- response_pcs[[pc]]\n    X <- as.matrix(predictor_pcs)\n    \n    if (!(pc %in% names(models))) {\n      cat(\"Model missing for PC:\", pc, \"\\n\")\n      next\n    }\n  \n    model <- models[[pc]]\n    preds <- predict(model, X, s = \"lambda.min\")\n    \n    if (any(is.na(preds))) {\n      cat(\"NA in predictions for PC:\", pc, \"\\n\")\n    }\n    \n    if (var(y) == 0) {\n      cat(\"Zero variance in y for PC:\", pc, \"\\n\")\n      next\n    }\n  \n    R2 <- cor(y, preds)^2\n    results[results$PC == pc, \"R2\"] <- R2\n  }\n  \n  return(results)\n}\n\nperformance_results <- evaluate_model_performance(models, Host_AFDW_pcs, vsd_miRNA)\nsummary(performance_results$R2)\n```\n:::\n\n\n# Results\n\nPlot results.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select top 20 predictive phys features\ntop_features <- feature_importance %>% top_n(20, MeanImportance)\n\n# Plot\nggplot(top_features, aes(x = reorder(Feature, MeanImportance), y = MeanImportance)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\") +\n  coord_flip() +  # Flip for readability\n  theme_minimal() +\n  labs(title = \"Top 20 Predictive Phys Features\",\n       x = \"Physiological Metric\",\n       y = \"Mean Importance\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(performance_results, aes(x = PC, y = R2)) +\n  geom_point(color = \"darkred\", size = 3) +\n  geom_hline(yintercept = mean(performance_results$R2, na.rm = TRUE), linetype = \"dashed\", color = \"blue\") +\n  theme_minimal() +\n  labs(title = \"Model Performance Across Gene Expression PCs\",\n       x = \"Gene Expression PC\",\n       y = \"R² (Variance Explained)\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate labels\n```\n:::\n\n\nKeep in mind that, while we ran the model with physiological predictors, we're really interested in the genes/miRNA associated with these predictors\n\nView components associated with gene/miRNA PCs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the PCA rotation (loadings) matrix from the original gene/miRNA PCA\nHost_AFDW_loadings <- pca_Host_AFDW$rotation  # Each column corresponds to a PC\n\n# Convert to data frame and reshape for plotting\nHost_AFDW_loadings_df <- as.data.frame(Host_AFDW_loadings) %>%\n  rownames_to_column(var = \"gene\") %>%\n  pivot_longer(-gene, names_to = \"Host_AFDW_PC\", values_to = \"Loading\")\n\n# View top CpGs contributing most to each PC\ntop_genes_Host_AFDW <- Host_AFDW_loadings_df %>%\n  group_by(Host_AFDW_PC) %>%\n  arrange(desc(abs(Loading))) %>%\n  slice_head(n = 20)  # Select top 10 CpGs per PC\n\nprint(top_genes_Host_AFDW)\n```\n:::\n\n\nView predicted vs actual gene expression values to evaluate model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Choose a gene expression PC to visualize (e.g., the most predictable one)\nbest_pc <- performance_results$PC[which.max(performance_results$R2)]\n\n# Extract actual and predicted values for that PC\nactual_values <- Host_AFDW_pcs[[best_pc]]\npredicted_values <- predict(models[[best_pc]], as.matrix(vsd_miRNA), s = \"lambda.min\")\n\n# Create data frame\nprediction_df <- data.frame(\n  Actual = actual_values,\n  Predicted = predicted_values\n)\n\n# Scatter plot with regression line\nggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n  geom_point(color = \"blue\", alpha = 0.7) +\n  geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n  theme_minimal() +\n  labs(title = paste(\"Predicted vs. Actual for\", best_pc),\n       x = \"Actual Gene Expression PC\",\n       y = \"Predicted Gene Expression PC\") +\n  annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n           label = paste(\"R² =\", round(max(performance_results$R2, na.rm=TRUE), 3)), \n           hjust = 0, color = \"black\", size = 5)\n## `geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n\nView top 20 genes associated with PC5 (the PC with the highest R\\^2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(top_genes_Host_AFDW%>%filter(Host_AFDW_PC==best_pc))\n```\n:::\n\n\nPlot performance for all PCs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select all PCs with R^2 values above line in plot\nall_pcs <- performance_results %>% filter(R2 > 0.75) %>% pull(PC)\n\nfor (pc in all_pcs) {\n  \n  # Extract actual and predicted values for that PC\n  actual_values <- Host_AFDW_pcs[[pc]]\n  predicted_values <- predict(models[[pc]], as.matrix(vsd_miRNA), s = \"lambda.min\")\n  \n  # Create data frame\n  prediction_df <- data.frame(\n    Actual = actual_values,\n    Predicted = predicted_values\n  )\n  \n  # Scatter plot with regression line\n  plot <- ggplot(prediction_df, aes(x = Actual, y = lambda.min)) +\n    geom_point(color = \"blue\", alpha = 0.7) +\n    geom_smooth(method = \"lm\", color = \"red\", se = FALSE) +\n    theme_minimal() +\n    labs(title = paste(\"Predicted vs. Actual for\", pc),\n         x = \"Actual Gene Expression PC\",\n         y = \"Predicted Gene Expression PC\") +\n    annotate(\"text\", x = min(actual_values), y = max(predicted_values), \n             label = paste(\"R² =\", round(max(performance_results[performance_results$PC==pc,2], na.rm=TRUE), 3)), \n             hjust = 0, color = \"black\", size = 5)\n  \n  print(plot)\n}\n```\n:::\n\n\nWe can also look att which miRNA(s) contributed most to predicting gene PCs of interest\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_feature_importance_for_pc <- function(model) {\n  coefs <- as.matrix(coef(model, s = \"lambda.min\"))[-1, , drop = FALSE]  # Remove intercept\n  coefs_df <- data.frame(Feature = rownames(coefs), Importance = abs(as.numeric(coefs)))\n  \n  return(coefs_df %>% arrange(desc(Importance)))  # Sort by importance\n}\n\nfor (pc in all_pcs) {\n  # Extract feature importance for the most predictable PC\n  best_pc_model <- models[[pc]]\n  best_pc_importance <- get_feature_importance_for_pc(best_pc_model)\n  \n  # Plot top most important miRNA for predicting this PC\n  plot <- ggplot(best_pc_importance %>% head(20), aes(x = reorder(Feature, Importance), y = Importance)) +\n    geom_bar(stat = \"identity\", fill = \"steelblue\") +\n    coord_flip() +\n    theme_minimal() +\n    labs(title = paste(\"Top miRNA Predictors for\", pc),\n         x = \"miRNA\",\n         y = \"Importance Score\")\n  \n  print(plot)\n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}